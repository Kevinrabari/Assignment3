"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEnumsCollector = void 0;
var typescript_1 = require("typescript");
var tags_1 = require("../../common/tags");
var logging_1 = require("../../logging");
var ts_type_resolving_1 = require("../../common/ts-type-resolving");
function getValuesFromEnumLikeType(checker, declaration, baseDir) {
    var type = checker.getTypeAtLocation(declaration);
    if (type.isUnion()) {
        var symb = ts_type_resolving_1.getTypeSymbol(type);
        if (symb === undefined) {
            return undefined;
        }
        var symbolType = tags_1.getSymbolType(symb, checker, baseDir);
        var typeArgs = symbolType === null || symbolType === void 0 ? void 0 : symbolType.typeArguments;
        if (isEnumValues(typeArgs)) {
            if (isStringEnumValues(typeArgs)) {
                var values = typeArgs.map(function (v) { return v.value.replace('\'', '').replace('\'', ''); });
                return { kind: 'enum', values: values, valueType: 'string' };
            }
            return {
                kind: 'enum',
                values: typeArgs.map(function (v) { return v.value; }),
                valueType: 'number',
            };
        }
    }
    if (type.isLiteral()) {
        var value = type.value;
        var typeName = typeof value;
        if (typeName === 'string' || typeName === 'number') {
            var values = [value];
            return { kind: 'enum', valueType: typeName, values: values };
        }
    }
    return undefined;
}
function isEnumValues(values) {
    var typeSet = new Set();
    values.forEach(function (v) {
        typeSet.add(v.id).add(typeof v.value);
    });
    return typeSet.size === 1;
}
function isStringEnumValues(parsedValues) {
    return isEnumValues(parsedValues) && parsedValues[0].id === 'string';
}
function createEnumsCollector(checker, baseDir) {
    var enumLikeTypes = new Map();
    function update(enumName, enumValues) {
        var typeName = "Enums." + enumName;
        if (enumLikeTypes.has(typeName)) {
            var enumType = enumLikeTypes.get(typeName);
            if (enumType.valueType === 'string' && enumValues.valueType === 'string') {
                enumType.values = __spreadArrays(enumType.values, enumValues.values);
            }
            else if (enumType.valueType === 'number' && enumValues.valueType === 'number') {
                enumType.values = __spreadArrays(enumType.values, enumValues.values);
            }
            else {
                logging_1.log("Enums with the same name " + enumName + ", but different values", { lvl: 'error' });
            }
        }
        else {
            enumLikeTypes.set(typeName, enumValues);
        }
    }
    function add(symbol, fileName) {
        if (fileName.includes('renovation'))
            return;
        var enumValues = symbol.declarations
            .filter(typescript_1.isTypeAliasDeclaration)
            .map(function (declaration) { return getValuesFromEnumLikeType(checker, declaration, baseDir); })
            .find(Boolean);
        if (!enumValues)
            return;
        var enumName = symbol.escapedName.toString();
        update(enumName, enumValues);
    }
    function toRecord() {
        return Object.fromEntries(enumLikeTypes.entries());
    }
    return { add: add, toRecord: toRecord };
}
exports.createEnumsCollector = createEnumsCollector;
//# sourceMappingURL=enum-collecting.js.map