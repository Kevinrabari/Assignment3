"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExportedDescriptors = exports.parseFiles = exports.discoverMembers = exports.discover = void 0;
var fs_1 = require("fs");
var path_1 = require("path");
var typescript_1 = require("typescript");
var tags_1 = require("../common/tags");
var processing_1 = require("./processing");
var ts_utils_1 = require("../common/ts-utils");
var utils_1 = require("../common/utils");
var logging_1 = require("../logging");
var ts_type_resolving_1 = require("../common/ts-type-resolving");
var enum_collecting_1 = require("./parsing/enum-collecting");
function discover(paths, exclude) {
    var targetDir = paths.scripts;
    var outputFile = paths.output;
    var fileNames = utils_1.enumerateFiles(targetDir, '.ts', exclude);
    logging_1.log(fileNames.length + " files discovered");
    var normalizedResult = discoverMembers(fileNames, targetDir);
    logging_1.log(normalizedResult.members.length + " members descriptors discovered");
    fs_1.writeFileSync(outputFile, JSON.stringify(normalizedResult, null, 2));
}
exports.discover = discover;
function discoverMembers(fileNames, baseDir) {
    var _a = parseFiles(fileNames, baseDir), descriptors = _a[0], types = _a[1];
    var members = descriptors
        .filter(function (e) { return Object.entries(e.tags).length > 0; })
        .map(function (descriptor) {
        var member = { tags: tags_1.buildMemberTags(descriptor.tags) };
        switch (descriptor.kind) {
            case 'option': {
                var type = descriptor.type, optional = descriptor.optional;
                if (type) {
                    member.type = { name: type.name };
                    if (type.cat === 'custom' || type.cat === 'custom-generic')
                        member.type.file = type.file;
                }
                if (optional)
                    member.optional = true;
                break;
            }
            case 'widget':
                member.optionsType = descriptor.optionsType;
                break;
        }
        if (descriptor.location)
            member.location = descriptor.location;
        if (descriptor.typeParameters)
            member.typeParameters = descriptor.typeParameters;
        return member;
    })
        .sort(compare);
    return {
        members: members,
        types: utils_1.toSortedRecord(types),
    };
}
exports.discoverMembers = discoverMembers;
function parseFiles(files, baseDir) {
    var program = typescript_1.createProgram(files, {});
    var checker = program.getTypeChecker();
    var processTypes = ts_type_resolving_1.createTypeProcessor(checker, baseDir);
    var descriptors = [];
    var tsTypes = {};
    var _a = enum_collecting_1.createEnumsCollector(checker, baseDir), add = _a.add, toRecord = _a.toRecord;
    files.forEach(function (filePath) {
        processFile(filePath);
    });
    function addDescriptor(descriptor, file) {
        if (descriptor === undefined)
            return;
        descriptors.push(__assign(__assign({}, descriptor), { location: descriptor.location || { file: file } }));
    }
    function getExportedMembers(sourceFile) {
        var fileSymbol = checker.getSymbolAtLocation(sourceFile);
        if (!fileSymbol)
            return [];
        return checker.getExportsOfModule(fileSymbol);
    }
    function processFile(filePath) {
        var sourceFile = program.getSourceFile(filePath);
        if (sourceFile.text.length === 0)
            throw new Error("Empty file: " + filePath);
        var file = path_1.relative(baseDir, filePath);
        for (var _i = 0, _a = getExportedMembers(sourceFile); _i < _a.length; _i++) {
            var member = _a[_i];
            proccessMemberDescriptors(member, sourceFile.fileName, file, checker, baseDir, addDescriptor);
            add(member, file);
            if (tags_1.hasTag(member, 'docid') || ts_type_resolving_1.isPublicType(member)) {
                processTypes(member, tsTypes);
            }
        }
    }
    return [descriptors, __assign(__assign({}, tsTypes), toRecord())];
}
exports.parseFiles = parseFiles;
function proccessMemberDescriptors(member, fileName, file, checker, baseDir, addDescriptor) {
    var _a = processing_1.getModuleAndExport(member, baseDir), moduleName = _a[0], exportName = _a[1];
    var moduleAndExportTags = [
        { name: 'module', value: moduleName },
        { name: 'export', value: exportName },
    ];
    var reportDuplicateTag = function (tagName) {
        logging_1.log("\"" + tagName + "\" tag can be deleted", { lvl: 'warn', node: member.declarations[0] });
    };
    var exportedDescriptors = getExportedDescriptors(member, fileName, checker, baseDir).filter(function (d) { return !!(d === null || d === void 0 ? void 0 : d.tags.length); });
    exportedDescriptors.forEach(function (d) {
        var descriptor = __assign({}, d);
        if (descriptor.exported) {
            descriptor.tags = tags_1.mergeTags(descriptor.tags, moduleAndExportTags, reportDuplicateTag);
        }
        addDescriptor(descriptor, file);
    });
    if (processing_1.hasMultipleDeclarations(member))
        return;
    var descriptor = getDescriptorFromSymbol(member, checker, baseDir);
    if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.tags.length) {
        descriptor.tags = tags_1.mergeTags(descriptor.tags, moduleAndExportTags, reportDuplicateTag);
        addDescriptor(descriptor, file);
    }
}
function getExportedDescriptors(member, fileName, checker, baseDir) {
    var declarations = member.declarations
        .filter(function (d) { return d.getSourceFile().fileName === fileName; });
    if (declarations.length > 1) {
        return declarations.map(function (d) { return (typescript_1.isFunctionDeclaration(d)
            ? processing_1.getMemberFromFunctionDeclaration(d, checker, baseDir)
            : undefined); }).filter(function (d) { return d; });
    }
    var declaration = member.declarations[0];
    if (typescript_1.isExportSpecifier(declaration))
        return [processing_1.getMemberFromExportSpecifier(declaration)];
    if (typescript_1.isExportAssignment(declaration)) {
        return processing_1.getMembersFromExportAssignment(checker, declaration, baseDir);
    }
    if (typescript_1.isTypeAliasDeclaration(declaration)) {
        return processing_1.getMembersFromTypeAliasDeclaration(declaration, checker, baseDir);
    }
    return processing_1.getMembersFromDeclaration(declaration, checker, baseDir);
}
exports.getExportedDescriptors = getExportedDescriptors;
function getDescriptorFromSymbol(member, checker, baseDir) {
    if (processing_1.hasMultipleDeclarations(member))
        return undefined;
    var declaration = member.declarations[0];
    var optionsTypeSymbol = getOptionsTypeSymbol(declaration, checker);
    var isWidget = !!optionsTypeSymbol;
    var tags = tags_1.getSymbolTags(checker, member, baseDir);
    if (!tags)
        return undefined;
    var typeParameters = processing_1.getTypeParameters(checker, member, baseDir);
    if (!isWidget) {
        return {
            kind: 'option',
            exported: true,
            tags: tags,
            typeParameters: typeParameters,
            optional: false,
        };
    }
    if (optionsTypeSymbol.declarations.length !== 1) {
        throw new Error("Partial declaration of options type not expected: " + optionsTypeSymbol.name);
    }
    return {
        kind: 'widget',
        exported: true,
        tags: tags,
        typeParameters: typeParameters,
        optionsType: {
            name: optionsTypeSymbol.name,
            file: path_1.relative(baseDir, optionsTypeSymbol.declarations[0].getSourceFile().fileName),
        },
    };
}
function getOptionsTypeSymbol(node, checker) {
    var _a;
    var type = checker.getTypeAtLocation(node);
    if (!((_a = getAllBaseTypes(type)) === null || _a === void 0 ? void 0 : _a.some((isWrappable))))
        return undefined;
    var optionsPropSymbol = type.getProperty('option');
    if (optionsPropSymbol === undefined)
        return undefined;
    var resolvedType = checker.getTypeOfSymbolAtLocation(optionsPropSymbol, optionsPropSymbol.valueDeclaration);
    if (resolvedType === undefined)
        return undefined;
    var returnType = checker
        .getSignaturesOfType(resolvedType, typescript_1.SignatureKind.Call)
        .find(function (s) { return s.parameters.length === 0; })
        .getReturnType()
        .symbol;
    if (returnType === undefined)
        return undefined;
    var paramDeclarations = returnType.declarations.filter(typescript_1.isTypeParameterDeclaration);
    if (paramDeclarations.length === returnType.declarations.length) {
        if (paramDeclarations.length !== 1)
            throw new Error('Partial declaration of type parameter not expected');
        return paramDeclarations[0].default
            ? checker.getTypeAtLocation(paramDeclarations[0].default).symbol
            : undefined;
    }
    return returnType;
}
function getAllBaseTypes(type) {
    if (type === undefined) {
        return [];
    }
    var baseTypes = ts_utils_1.isTypeReference(type)
        ? type.target.getBaseTypes()
        : type.getBaseTypes();
    return baseTypes === null || baseTypes === void 0 ? void 0 : baseTypes.reduce(function (acc, next) {
        acc.push(next);
        acc.push.apply(acc, getAllBaseTypes(next));
        return acc;
    }, []);
}
function isWrappable(type) {
    return type.symbol.getJsDocTags().some(function (t) { return t.name === 'wrappable'; });
}
function compare(a, b) {
    var result = compareAttrValues(getNameForComparison(a), getNameForComparison(b));
    return result !== 0 ? result : compareAttrValues(a.tags.name, b.tags.name);
}
function getNameForComparison(doc) {
    return doc.tags.const || doc.tags.docid;
}
function compareAttrValues(a, b) {
    if (a === undefined && b === undefined)
        return 0;
    if (a === undefined)
        return -1;
    if (b === undefined)
        return 1;
    return a[0].localeCompare(b[0]);
}
//# sourceMappingURL=discovering.js.map