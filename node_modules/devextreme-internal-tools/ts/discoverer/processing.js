"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleAndExport = exports.hasMultipleDeclarations = exports.getMembersFromExportAssignment = exports.getMemberFromExportSpecifier = exports.getMembersFromPropType = exports.getMembersFromTypeAliasDeclaration = exports.getMemberFromFunctionDeclaration = exports.getMembersFromDeclaration = exports.getTypeParameters = void 0;
var path_1 = require("path");
var typescript_1 = require("typescript");
var tags_1 = require("../common/tags");
var discovering_error_1 = require("./discovering-error");
var ts_utils_1 = require("../common/ts-utils");
var ts_type_resolving_1 = require("../common/ts-type-resolving");
function getTypeParameters(checker, member, baseDir) {
    var typeParams = GetGenericParameters(member);
    if (!typeParams.length)
        return undefined;
    var result = {};
    typeParams.forEach(function (p) {
        result[p.name.escapedText.toString()] = GetGenericParamDeclaration(p, checker, baseDir);
    });
    return result;
}
exports.getTypeParameters = getTypeParameters;
function GetGenericParamDeclaration(genericParam, checker, baseDir) {
    return {
        defaultValue: genericParam.default
            ? ts_type_resolving_1.resolveType(genericParam.default, checker, baseDir)
            : undefined,
    };
}
function GetGenericParameters(member) {
    var declaration = member.declarations[0];
    var result = [];
    if ((typescript_1.isTypeAliasDeclaration(declaration) || typescript_1.isInterfaceDeclaration(declaration))
        && declaration.typeParameters) {
        declaration.typeParameters.forEach(function (p) { return result.push(p); });
    }
    return result;
}
function getMembersFromDeclaration(declaration, checker, targetDir) {
    if (typescript_1.isFunctionDeclaration(declaration)) {
        return [getMemberFromFunctionDeclaration(declaration, checker, targetDir)];
    }
    if (typescript_1.isVariableDeclaration(declaration)
        || typescript_1.isTypeLiteralNode(declaration)
        || typescript_1.isClassDeclaration(declaration)
        || typescript_1.isInterfaceDeclaration(declaration)) {
        return ts_utils_1.getNestedSymbols(checker.getTypeAtLocation(declaration))
            .map(function (s) {
            var members = getMembersFromSymbol(s, checker, targetDir);
            for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {
                var m = members_1[_i];
                m.exported = false;
            }
            return members;
        })
            .flat();
    }
    return [];
}
exports.getMembersFromDeclaration = getMembersFromDeclaration;
function getMemberFromFunctionDeclaration(declaration, checker, baseDir) {
    return {
        kind: 'option',
        exported: true,
        tags: tags_1.getSignatureDeclarationTags(checker, declaration, baseDir),
        optional: false,
    };
}
exports.getMemberFromFunctionDeclaration = getMemberFromFunctionDeclaration;
function getMembersFromTypeAliasDeclaration(declaration, checker, targetDir) {
    return getMembersFromPropType(checker.getTypeAtLocation(declaration.type), checker, declaration.getSourceFile().fileName, targetDir);
}
exports.getMembersFromTypeAliasDeclaration = getMembersFromTypeAliasDeclaration;
function getMembersFromSymbol(symbol, checker, targetDir) {
    if (!symbol.declarations) {
        return [];
    }
    var propDeclarations = [];
    var result = [];
    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
        var declaration = _a[_i];
        if (!registerDeclaration(declaration)) {
            continue;
        }
        if (typescript_1.isMethodDeclaration(declaration) || typescript_1.isMethodSignature(declaration)) {
            result.push({
                kind: 'option',
                exported: true,
                tags: tags_1.getSignatureDeclarationTags(checker, declaration, targetDir),
                optional: ts_utils_1.isOptional(symbol),
                location: {
                    file: path_1.relative(targetDir, declaration.getSourceFile().fileName),
                },
            });
        }
        else {
            var propType = checker.getTypeAtLocation(declaration);
            if (ts_utils_1.isStructuredType(propType)) {
                result.push.apply(result, getMembersFromPropType(propType, checker, declaration.getSourceFile().fileName, targetDir));
            }
            propDeclarations.push(declaration);
        }
    }
    if (propDeclarations.length !== 0) {
        result.push({
            kind: 'option',
            exported: true,
            tags: tags_1.getSymbolTags(checker, symbol, targetDir),
            type: extractType(propDeclarations, checker, targetDir),
            optional: ts_utils_1.isOptional(symbol),
            location: {
                file: path_1.relative(targetDir, symbol.declarations[0].getSourceFile().fileName),
            },
        });
    }
    return result;
}
function getMembersFromPropType(type, checker, targetFileName, targetDir) {
    var result = [];
    var symbols = ts_utils_1.getTypeSymbols(type);
    for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
        var symbol = symbols_1[_i];
        var declarations = symbol.getDeclarations();
        if (!declarations)
            continue;
        for (var _a = 0, declarations_1 = declarations; _a < declarations_1.length; _a++) {
            var declaration = declarations_1[_a];
            if (targetFileName !== declaration.getSourceFile().fileName) {
                continue;
            }
            result.push.apply(result, getMembersFromDeclaration(declaration, checker, targetDir));
        }
    }
    return result;
}
exports.getMembersFromPropType = getMembersFromPropType;
function extractType(declarations, checker, targetDir) {
    var _a;
    var type = checker.getTypeAtLocation(declarations[0]);
    var symbol = (_a = type.aliasSymbol) !== null && _a !== void 0 ? _a : type.symbol;
    if (!symbol)
        return undefined;
    if (symbol.flags & typescript_1.SymbolFlags.TypeLiteral)
        return undefined;
    if (!symbol.declarations)
        throw new discovering_error_1.DiscoveringError('Unable to find type declaration', declarations);
    var file = path_1.relative(targetDir, symbol.declarations[0].getSourceFile().fileName);
    if (/node_modules\\typescript\\.*\\lib\..*\.d\.ts/.test(file) || /node_modules\/typescript\/.*\/lib\..*\.d\.ts/.test(file))
        return undefined;
    var targetFlags = typescript_1.SymbolFlags.Interface | typescript_1.SymbolFlags.TypeAlias
        | typescript_1.SymbolFlags.Class | typescript_1.SymbolFlags.Enum;
    if (symbol.flags & targetFlags) {
        return {
            cat: 'custom',
            name: symbol.name,
            file: file,
        };
    }
    return undefined;
}
function getMemberFromExportSpecifier(declaration) {
    var adjacentExportSpecifiers = getAdjacentExportSpecifiers(declaration);
    var isSingleExport = adjacentExportSpecifiers && adjacentExportSpecifiers.length === 1;
    if (!isSingleExport)
        return undefined;
    var tags = typescript_1.getJSDocTags(declaration.parent.parent);
    if (!(tags === null || tags === void 0 ? void 0 : tags.length))
        return undefined;
    return {
        kind: 'option',
        exported: true,
        tags: tags.map(tags_1.normalizeTag),
        optional: false,
    };
}
exports.getMemberFromExportSpecifier = getMemberFromExportSpecifier;
function getAdjacentExportSpecifiers(node) {
    if (!node.parent)
        return undefined;
    var exportsListNodes = node.parent
        .getChildren()
        .filter(function (n) { return n.kind === typescript_1.SyntaxKind.SyntaxList; });
    if (exportsListNodes.length !== 1)
        return undefined;
    return exportsListNodes[0]
        .getChildren()
        .filter(function (n) { return n.kind === typescript_1.SyntaxKind.ExportSpecifier; });
}
function getMembersFromExportAssignment(checker, declaration, targetDir) {
    var result = [];
    if (declaration.expression.kind !== typescript_1.SyntaxKind.Identifier)
        return result;
    var declarationSymbol = checker.getSymbolAtLocation(declaration.expression);
    if (declarationSymbol && !hasMultipleDeclarations(declarationSymbol)) {
        result.push({
            kind: 'option',
            exported: true,
            tags: tags_1.getSymbolTags(checker, declarationSymbol, targetDir),
            optional: false,
        });
    }
    var type = checker.getTypeAtLocation(declaration.expression);
    var typeSymbol = type === null || type === void 0 ? void 0 : type.getSymbol();
    if (typeSymbol && !hasMultipleDeclarations(typeSymbol)) {
        result.push({
            kind: 'option',
            exported: true,
            tags: tags_1.getSymbolTags(checker, typeSymbol, targetDir),
            optional: false,
        });
    }
    result.push.apply(result, getMembersFromPropType(type, checker, declaration.getSourceFile().fileName, targetDir));
    return result;
}
exports.getMembersFromExportAssignment = getMembersFromExportAssignment;
function hasMultipleDeclarations(symbol) {
    var _a;
    return ((_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a.length) > 1;
}
exports.hasMultipleDeclarations = hasMultipleDeclarations;
var visitedDeclarations = new Set();
function registerDeclaration(d) {
    var name = d.getSourceFile().fileName + "|" + d.getStart().toString();
    if (name.indexOf('node_modules/') !== -1) {
        return false;
    }
    if (visitedDeclarations.has(name)) {
        return false;
    }
    visitedDeclarations.add(name);
    return true;
}
function getModuleAndExport(symbol, baseDir) {
    var moduleName = ts_utils_1.getModule(symbol.declarations[0], baseDir);
    var exportName = symbol.escapedName.toString();
    return [moduleName, exportName];
}
exports.getModuleAndExport = getModuleAndExport;
//# sourceMappingURL=processing.js.map