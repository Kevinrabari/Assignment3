"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCollapseFunction = exports.collapseJSDocs = exports.collapse = void 0;
var fs_1 = require("fs");
var typescript_1 = require("typescript");
var utils_1 = require("../common/utils");
var tags_1 = require("../common/tags");
var ts_utils_1 = require("../common/ts-utils");
var logging_1 = require("../logging");
var INTERNAL_MEMBER_WARNING = 'Attention! This type is for internal purposes only. If you used it previously, please describe your scenario in the following GitHub Issue, and we will suggest a public alternative: {@link https://github.com/DevExpress/DevExtreme/issues/17885|Internal Types}.';
function collapse(targetDir, exclude) {
    logging_1.log('Collapsing Declarations');
    var fileNames = utils_1.enumerateFiles(targetDir, '.d.ts', exclude);
    var collapseFile = createCollapseFunction(ts_utils_1.createProgram(fileNames));
    fileNames.forEach(function (path) {
        var content = collapseFile(path);
        if (content) {
            fs_1.writeFileSync(path, content);
        }
    });
    logging_1.log(fileNames.length + " files updated");
}
exports.collapse = collapse;
function collapseJSDocs(content) {
    var filePath = 'bundle.d.ts';
    var outputFile = typescript_1.createSourceFile(filePath, content, typescript_1.ScriptTarget.Latest);
    return createCollapseFunction(ts_utils_1.createProgram([outputFile]))(filePath);
}
exports.collapseJSDocs = collapseJSDocs;
var JSDocableNodesCache = (function () {
    function JSDocableNodesCache() {
        this.items = new Map();
    }
    JSDocableNodesCache.prototype.nodes = function () {
        return Array.from(this.items.values());
    };
    JSDocableNodesCache.prototype.add = function (node) {
        var existingNode = this.items.get(node.node);
        if (!existingNode || node.isExportedNode) {
            this.items.set(node.node, node);
        }
        return existingNode === undefined;
    };
    JSDocableNodesCache.prototype.push = function (nodes) {
        var _this = this;
        nodes.forEach(function (node) { return _this.add(node); });
    };
    return JSDocableNodesCache;
}());
function getDeclarationsFromStatement(statement, checker) {
    if (!typescript_1.isModuleDeclaration(statement)) {
        return [statement];
    }
    var moduleDeclaration = statement;
    while (typescript_1.isModuleDeclaration(moduleDeclaration.body)) {
        moduleDeclaration = moduleDeclaration.body;
    }
    if (moduleDeclaration.flags & typescript_1.NodeFlags.GlobalAugmentation) {
        return undefined;
    }
    return getModuleStatements(moduleDeclaration)
        .map(function (node) { return node && getDeclarationsFromStatement(node, checker); }).flat();
    function getModuleStatements(module) {
        var _a;
        var symbol = (_a = checker.getTypeAtLocation(module)) === null || _a === void 0 ? void 0 : _a.getSymbol();
        if (symbol) {
            return checker
                .getExportsOfModule(symbol)
                .map(function (s) { return s.getDeclarations(); })
                .flat();
        }
        if (typescript_1.isModuleBlock(module.body)) {
            return __spreadArrays(module.body.statements);
        }
        return [];
    }
}
function getJSDocableNodes(sourceFile, checker) {
    var _a;
    var fileSymbol = checker.getSymbolAtLocation(sourceFile);
    var exportedMembers = fileSymbol
        ? checker.getExportsOfModule(fileSymbol).map(function (s) { return s.getDeclarations(); }).flat()
        : (_a = sourceFile.statements) === null || _a === void 0 ? void 0 : _a.filter(typescript_1.isModuleDeclaration).map(function (node) { return getDeclarationsFromStatement(node, checker); }).flat().filter(function (s) { return s; });
    var nodesCache = new JSDocableNodesCache();
    for (var _i = 0, _b = utils_1.distinct(exportedMembers !== null && exportedMembers !== void 0 ? exportedMembers : []); _i < _b.length; _i++) {
        var declaration = _b[_i];
        if (declaration.getSourceFile() !== sourceFile)
            continue;
        if (typescript_1.isExportSpecifier(declaration)) {
            getMembersFromExportSpecifier(nodesCache, checker, declaration);
            continue;
        }
        if (typescript_1.isExportAssignment(declaration)) {
            getMembersFromExportAssignment(nodesCache, checker, declaration);
            continue;
        }
        if (typescript_1.isTypeAliasDeclaration(declaration)) {
            nodesCache.add({ node: declaration, isExportedNode: true });
            getMembersFromTypeAliasDeclaration(nodesCache, checker, declaration);
            continue;
        }
        getMembersFromDeclaration(nodesCache, checker, declaration, true);
    }
    return nodesCache
        .nodes()
        .sort(function (a, b) { return b.node.getStart(sourceFile) - a.node.getStart(sourceFile); });
}
function createCollapseFunction(program) {
    var checker = program.getTypeChecker();
    return function (file) { return collapseFileContent(program.getSourceFile(file), checker); };
}
exports.createCollapseFunction = createCollapseFunction;
function collapseFileContent(sourceFile, checker) {
    var _a, _b, _c, _d, _e, _f, _g;
    var nodes = getJSDocableNodes(sourceFile, checker)
        .filter(function (_a) {
        var _b;
        var node = _a.node, isExportedNode = _a.isExportedNode;
        if (!isExportedNode && !((_b = typescript_1.getJSDocTags(node)) === null || _b === void 0 ? void 0 : _b.length)) {
            return false;
        }
        return true;
    });
    var sourceText = sourceFile.getFullText();
    var contents = [];
    for (var i = 0; i < nodes.length; i += 1) {
        var _h = nodes[i], node = _h.node, isExportedNode = _h.isExportedNode;
        var tags = typescript_1.getJSDocTags(node);
        var publicName = (_a = tags.find(function (t) { return t.tagName.text === 'publicName'; })) === null || _a === void 0 ? void 0 : _a.comment;
        var docidTag = tags.find(function (t) { return t.tagName.text === 'docid'; });
        var constTag = tags.find(function (t) { return t.tagName.text === 'const'; });
        var isPrivate = isExportedNode && tags.find(function (t) { return t.tagName.text === 'public'; }) === undefined;
        var deprecatedTag = tags.find(function (t) { return t.tagName.text === 'deprecated'; });
        var isDeprecated = deprecatedTag !== undefined;
        var docid = '';
        if (docidTag || constTag) {
            docid = (docidTag === null || docidTag === void 0 ? void 0 : docidTag.comment) || (constTag === null || constTag === void 0 ? void 0 : constTag.comment)
                || tags_1.getFullyQualifiedName(getNodeSymbol(node));
        }
        if (docid && publicName && publicName.includes('(')) {
            docid = docid.substring(0, docid.lastIndexOf('.') + 1) + publicName;
        }
        docid = patchMemberName(docid);
        var targetNode = typescript_1.isVariableDeclaration(node) ? node.parent.parent : node;
        var indent = ((_b = tags[0]) === null || _b === void 0 ? void 0 : _b.parent) ? new Array(targetNode.getStart() - tags[0].parent.end).join(' ')
            : (_e = (_d = (_c = targetNode
                .getFullText()
                .match(/^(?<indent> *?)\w/m)) === null || _c === void 0 ? void 0 : _c.groups) === null || _d === void 0 ? void 0 : _d.indent) !== null && _e !== void 0 ? _e : '';
        var separator = "\n" + indent;
        var deprecatedMessage = docid ? "[depNote:" + docid + "]" : (deprecatedTag === null || deprecatedTag === void 0 ? void 0 : deprecatedTag.comment) || '';
        var comments = __spreadArrays([
            '/**'
        ], [docid && " * [descr:" + docid + "]"], [isDeprecated && " * @deprecated " + deprecatedMessage], [isPrivate && " * @deprecated " + INTERNAL_MEMBER_WARNING], [
            ' */',
        ]).filter(function (s) { return s; });
        var comment = comments.length > 2 ? "" + comments.join(separator) + separator : '';
        var nodePos = targetNode.getStart();
        if (i === 0) {
            contents.push(sourceText.substring(nodePos));
        }
        contents.push(comment);
        contents.push(sourceText.substring(getPrevNodeStart(nodes, i), ((_f = tags[0]) === null || _f === void 0 ? void 0 : _f.parent) ? (_g = tags[0]) === null || _g === void 0 ? void 0 : _g.parent.pos : nodePos));
    }
    return contents.reverse().join('');
    function getPrevNodeStart(allNodes, curIndex) {
        var _a;
        var node = ((_a = allNodes[curIndex + 1]) !== null && _a !== void 0 ? _a : {}).node;
        if (!node) {
            return 0;
        }
        var targetNode = typescript_1.isVariableDeclaration(node) ? node.parent.parent : node;
        return targetNode.getStart();
    }
    function getNodeSymbol(node) {
        var symbol = checker.getSymbolAtLocation(node);
        if (!symbol) {
            for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {
                var childNode = _a[_i];
                symbol = checker.getSymbolAtLocation(childNode);
                if (symbol)
                    break;
            }
        }
        return symbol;
    }
    function patchMemberName(name) {
        return name
            .replace(/(?<=\w+)(Methods|Events)/m, '');
    }
}
function getMembersFromSymbol(cache, checker, symbol, targetFile) {
    if (!symbol.declarations) {
        return;
    }
    for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
        var declaration = _a[_i];
        if (targetFile !== declaration.getSourceFile()) {
            continue;
        }
        if (!cache.add({ node: declaration })) {
            continue;
        }
        var propType = checker.getTypeAtLocation(declaration);
        if (ts_utils_1.isStructuredType(propType)) {
            getMembersFromPropType(cache, checker, propType, declaration.getSourceFile());
        }
    }
}
function getMembersFromDeclaration(cache, checker, declaration, setExported) {
    if (setExported === void 0) { setExported = false; }
    if (!typescript_1.isTypeLiteralNode(declaration)) {
        cache.add({ node: declaration, isExportedNode: setExported });
    }
    if (typescript_1.isVariableDeclaration(declaration)
        || typescript_1.isTypeLiteralNode(declaration)
        || typescript_1.isClassDeclaration(declaration)
        || typescript_1.isInterfaceDeclaration(declaration)) {
        ts_utils_1.getNestedSymbols(checker.getTypeAtLocation(declaration))
            .forEach(function (s) { return getMembersFromSymbol(cache, checker, s, declaration.getSourceFile()); });
    }
}
function getMembersFromTypeAliasDeclaration(cache, checker, declaration) {
    getMembersFromPropType(cache, checker, checker.getTypeAtLocation(declaration.type), declaration.getSourceFile());
}
function getMembersFromPropType(cache, checker, type, targetFile) {
    for (var _i = 0, _a = ts_utils_1.getTypeSymbols(type); _i < _a.length; _i++) {
        var symbol = _a[_i];
        var declarations = symbol.getDeclarations();
        if (!declarations)
            continue;
        for (var _b = 0, declarations_1 = declarations; _b < declarations_1.length; _b++) {
            var declaration = declarations_1[_b];
            if (targetFile !== declaration.getSourceFile()) {
                continue;
            }
            getMembersFromDeclaration(cache, checker, declaration);
        }
    }
}
function getMembersFromExportExpression(cache, checker, identifier, targetFile) {
    var declarationSymbol = checker.getSymbolAtLocation(identifier);
    if (declarationSymbol) {
        cache.push(declarationSymbol
            .getDeclarations()
            .filter(function (node) { return targetFile === node.getSourceFile()
            && !typescript_1.isImportClause(node)
            && !typescript_1.isImportSpecifier(node); })
            .map(function (node) { return ({ node: node, isExportedNode: true }); }));
    }
    getMembersFromPropType(cache, checker, checker.getTypeAtLocation(identifier), targetFile);
}
function getMembersFromExportSpecifier(cache, checker, declaration) {
    if (declaration.propertyName) {
        getMembersFromExportExpression(cache, checker, declaration.propertyName, declaration.getSourceFile());
    }
}
function getMembersFromExportAssignment(cache, checker, declaration) {
    if (typescript_1.isIdentifier(declaration.expression)) {
        getMembersFromExportExpression(cache, checker, declaration.expression, declaration.getSourceFile());
    }
}
//# sourceMappingURL=collapser.js.map