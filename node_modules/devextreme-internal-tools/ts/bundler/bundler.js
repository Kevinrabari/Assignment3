"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processFiles = exports.bundle = void 0;
var fs_1 = require("fs");
var path_1 = require("path");
var prettier_1 = require("prettier");
var typescript_1 = require("typescript");
var utils_1 = require("../common/utils");
var ts_utils_1 = require("../common/ts-utils");
var collapser_1 = require("../collapser/collapser");
var type_resolving_1 = require("../common/type-resolving");
var logging_1 = require("../logging");
var GLOBAL_MODULE_NAME = 'global';
function formatFileContent(content) {
    return prettier_1.format(content, { parser: 'typescript', singleQuote: true });
}
function bundle(paths, exclude) {
    logging_1.log('Creating TS bundle');
    var fileNames = utils_1.enumerateFiles(paths.scriptsDir, '.d.ts', exclude);
    var bundleContent = processFiles(fileNames, paths.scriptsDir);
    if (bundleContent) {
        fs_1.writeFileSync(paths.outputFile, bundleContent);
        logging_1.log("Bundle saved to " + paths.outputFile);
    }
    else {
        logging_1.log('Nothing to save');
    }
}
exports.bundle = bundle;
function processFiles(files, scriptsDir) {
    var _a;
    var program = typescript_1.createProgram(files, {});
    var checker = program.getTypeChecker();
    var programFiles = files.map(function (f) { return program.getSourceFile(f); });
    var nodesCache = new Set();
    for (var _i = 0, programFiles_1 = programFiles; _i < programFiles_1.length; _i++) {
        var sourceFile = programFiles_1[_i];
        var fileSymbol = checker.getSymbolAtLocation(sourceFile);
        var exportedMembers = checker.getExportsOfModule(fileSymbol);
        for (var _b = 0, exportedMembers_1 = exportedMembers; _b < exportedMembers_1.length; _b++) {
            var member = exportedMembers_1[_b];
            var nodes = [];
            var _loop_1 = function (declaration) {
                if (!typescript_1.isExportAssignment(declaration)) {
                    nodes.push(declaration);
                }
                else if (typescript_1.isIdentifier(declaration.expression)) {
                    nodes.push.apply(nodes, (_a = checker.getSymbolAtLocation(declaration.expression)) === null || _a === void 0 ? void 0 : _a.getDeclarations().filter(function (node) { return declaration.getSourceFile() === node.getSourceFile()
                        && !typescript_1.isImportClause(node)
                        && !typescript_1.isImportSpecifier(node); }));
                }
            };
            for (var _c = 0, _d = member.declarations; _c < _d.length; _c++) {
                var declaration = _d[_c];
                _loop_1(declaration);
            }
            nodes.forEach(function (declaration) { return processDeclaration(nodesCache, programFiles, checker, declaration, true); });
        }
    }
    return buildBundle(checker, nodesCache, scriptsDir);
}
exports.processFiles = processFiles;
function buildBundle(checker, nodesCache, scriptsDir) {
    var bundleContent = buildModules(checker, nodesCache, scriptsDir)
        .map(function (info) {
        var nodesText = info.members.map(function (member) { return member.getText(); }).join('\n');
        var moduleStr = info.name === GLOBAL_MODULE_NAME ? GLOBAL_MODULE_NAME : "module " + info.name;
        return "declare " + moduleStr + " {\n" + nodesText + "\n}";
    })
        .join('\n');
    return collapser_1.collapseJSDocs(formatFileContent(bundleContent));
}
function getExplicitNodeNamespace(node) {
    var _a;
    return (_a = typescript_1.getJSDocTags(node)
        .find(function (t) { return t.tagName.text === 'namespace'; })) === null || _a === void 0 ? void 0 : _a.comment;
}
function getModuleName(node, rootPath) {
    var nameDeclaration = typescript_1.isModuleBlock(node.parent) ? node.parent.parent.name : undefined;
    if (nameDeclaration && typescript_1.isIdentifier(nameDeclaration)) {
        return nameDeclaration.text;
    }
    return fileNameToModuleName(getModuleFileName(node, nameDeclaration), rootPath);
}
function fileNameToModuleName(fileName, rootPath) {
    var dir = path_1.dirname(path_1.relative(rootPath, fileName))
        .split(path_1.sep)
        .shift()
        .replace(/_(\w)/, function (_, p1) { return p1.toUpperCase(); });
    return dir && dir !== '.' ? "DevExpress." + dir : 'DevExpress';
}
function getModuleFileName(node, moduleName) {
    var fileName = node.getSourceFile().fileName;
    return (moduleName && typescript_1.isStringLiteral(moduleName))
        ? path_1.join(path_1.dirname(fileName), moduleName.text)
        : fileName;
}
function getSubmoduleNames(node, checker, rootPath) {
    var _a;
    var sourceFile = node.getSourceFile();
    var fileSymbol = checker.getSymbolAtLocation(sourceFile);
    var classDefaultExport = checker
        .getExportsOfModule(fileSymbol)
        .map(getClassDefaultExport)
        .find(function (d) { return d !== undefined; });
    if (classDefaultExport === undefined || classDefaultExport === node) {
        return undefined;
    }
    return [
        getExplicitNodeNamespace(classDefaultExport) || getModuleName(classDefaultExport, rootPath),
        (_a = classDefaultExport.name) === null || _a === void 0 ? void 0 : _a.text,
    ];
    function getClassDefaultExport(symbol) {
        return ts_utils_1.getSymbolDecalartions(symbol, checker)
            .filter(function (d) { return d.getSourceFile() === sourceFile; })
            .filter(typescript_1.isClassDeclaration)
            .find(function (d) { return isDefaultDeclaration(d, symbol); });
    }
}
function isDefaultDeclaration(declaration, symbol) {
    var _a, _b;
    return !!((_a = declaration.modifiers) === null || _a === void 0 ? void 0 : _a.find(function (m) { return m.kind === typescript_1.SyntaxKind.DefaultKeyword; }))
        || symbol.name === 'default'
        || !!((_b = declaration.name) === null || _b === void 0 ? void 0 : _b.text.match(/^(Base)[A-Z]/));
}
function getNodeText(checker, node, allNodes) {
    var target = typescript_1.isVariableDeclaration(node.node)
        ? node.node.parent.parent
        : node.node;
    var text = target
        .getFullText()
        .trim()
        .replace(/\s*\/(\/.*?|\*[^*][\s\S]*?\*\/)$/gm, '')
        .replace(/^declare /m, 'export ')
        .replace('export default ', 'export ');
    var renames = getNodeRenames(node, allNodes, checker);
    if ((renames === null || renames === void 0 ? void 0 : renames.length) > 0) {
        renames.forEach(function (_a) {
            var str = _a[0], replacement = _a[1];
            text = text.replace(new RegExp("([,:<(=>|&\\w]\\s*\\b)" + str + "\\b(?![?:(])", 'gm'), "$1" + replacement);
        });
    }
    return text;
}
function buildModules(checker, nodesCache, rootDir) {
    var nodes = new Map();
    var modules = new Map();
    nodesCache.forEach(function (node) {
        var _a;
        var nodeNamespace = getExplicitNodeNamespace(node);
        var submoduleNames = !nodeNamespace ? getSubmoduleNames(node, checker, rootDir) : undefined;
        var moduleName = nodeNamespace || (submoduleNames === null || submoduleNames === void 0 ? void 0 : submoduleNames[0]) || getModuleName(node, rootDir);
        var bNode = {
            node: node,
            module: moduleName,
            submodule: (submoduleNames === null || submoduleNames === void 0 ? void 0 : submoduleNames[1]) || undefined,
        };
        nodes.set(node, bNode);
        var moduleNodes = (_a = modules.get(moduleName)) !== null && _a !== void 0 ? _a : [];
        moduleNodes.push(bNode);
        modules.set(moduleName, moduleNodes);
    });
    var modulesInfo = Array.from(modules)
        .map(function (_a) {
        var moduleName = _a[0], moduleNodes = _a[1];
        return ({
            name: moduleName,
            members: getModuleNodes(checker, moduleNodes, nodes)
                .concat(getModuleSubmodules(checker, moduleNodes, nodes))
                .sort(function (a, b) { return String(a.sortName).localeCompare(b.sortName); }),
        });
    })
        .sort(function (a, b) {
        if (a.name === GLOBAL_MODULE_NAME)
            return -1;
        if (b.name === GLOBAL_MODULE_NAME)
            return 1;
        return String(a.name).localeCompare(b.name);
    });
    return modulesInfo;
}
function getModuleNodes(checker, moduleNodes, allNodes) {
    return moduleNodes
        .filter(function (node) { return !node.submodule; })
        .map(function (node) { return ({
        sortName: ts_utils_1.getNodeName(node.node),
        getText: function () { return getNodeText(checker, node, allNodes); },
    }); });
}
function getModuleSubmodules(checker, moduleNodes, allNodes) {
    var submodules = new Map();
    moduleNodes
        .forEach(function (node) {
        var _a;
        if (!node.submodule) {
            return;
        }
        var submoduleNodes = (_a = submodules.get(node.submodule)) !== null && _a !== void 0 ? _a : [];
        submoduleNodes.push(node);
        submodules.set(node.submodule, submoduleNodes);
    });
    return Array.from(submodules).map(function (_a) {
        var submoduleName = _a[0], submoduleNodes = _a[1];
        return ({
            sortName: submoduleName,
            getText: function () {
                var nodesText = submoduleNodes
                    .sort(function (a, b) { return String(ts_utils_1.getNodeName(a.node)).localeCompare(ts_utils_1.getNodeName(b.node)); })
                    .map(function (node) { return getNodeText(checker, node, allNodes); }).join('\n');
                return "module " + submoduleName + " {\n" + nodesText + "\n}";
            },
        });
    });
}
function getReferenceNodes(node, checker) {
    var nodes = [];
    findRefs(node);
    return utils_1.distinct(nodes);
    function findRefs(n) {
        var _a, _b;
        if (typescript_1.isTypeReferenceNode(n)) {
            if (type_resolving_1.getGenericParameterDeclaration(n, checker)) {
                return;
            }
            nodes.push(n);
            (_a = n.typeArguments) === null || _a === void 0 ? void 0 : _a.forEach(function (c) { return findRefs(c); });
        }
        else {
            if ((typescript_1.isClassDeclaration(n) || typescript_1.isInterfaceDeclaration(n)) && ((_b = n.heritageClauses) === null || _b === void 0 ? void 0 : _b.length)) {
                nodes.push.apply(nodes, n.heritageClauses.map(function (hc) { return __spreadArrays(hc.types); }).flat());
            }
            n.getChildren().forEach(function (c) { return findRefs(c); });
        }
    }
}
function getNodeRenames(node, allNodes, checker) {
    return utils_1.distinct(getReferenceNodes(node.node, checker)
        .map(function (tsNode) {
        var targetNode = allNodes.get(resolveReferenceNode(tsNode, checker)[0]);
        if (!targetNode || targetNode.module === GLOBAL_MODULE_NAME) {
            return undefined;
        }
        var nodeNS = utils_1.buildQualifiedName(node.module, node.submodule);
        var targetNodeNS = utils_1.buildQualifiedName(targetNode.module, targetNode.submodule);
        var tsNodeName = ts_utils_1.getNodeName(tsNode);
        var targetNodeName = ts_utils_1.getNodeName(targetNode.node);
        if (tsNodeName && (targetNodeNS !== nodeNS || tsNodeName !== targetNodeName)) {
            return [tsNodeName, !nodeNS.startsWith(targetNodeNS) ? targetNodeNS + "." + targetNodeName : targetNodeName];
        }
        return undefined;
    })
        .filter(function (str) { return str; }), function (item) { return item[0]; });
}
function isNodePublic(node) {
    var tags = typescript_1.getJSDocTags(node);
    if (!(tags === null || tags === void 0 ? void 0 : tags.length)) {
        return false;
    }
    var hasDocidTag = tags.find(function (t) { return t.tagName.text === 'docid'; });
    var hasConstTag = tags.find(function (t) { return t.tagName.text === 'const'; });
    var hasPublicTag = tags.find(function (t) { return t.tagName.text === 'public'; });
    if (hasPublicTag || hasDocidTag || hasConstTag) {
        return true;
    }
    return false;
}
function processDeclaration(cache, programFiles, checker, declaration, checkPublicity) {
    if (checkPublicity === void 0) { checkPublicity = false; }
    if (!programFiles.find(function (f) { return f === declaration.getSourceFile(); })) {
        return;
    }
    if (!typescript_1.isTypeLiteralNode(declaration)) {
        if (checkPublicity && !isNodePublic(declaration)) {
            return;
        }
        if (cache.has(declaration)) {
            return;
        }
        cache.add(declaration);
    }
    getReferenceNodes(declaration, checker)
        .forEach(function (refNode) { return resolveReferenceNode(refNode, checker)
        .forEach(function (node) { return processDeclaration(cache, programFiles, checker, node); }); });
}
function resolveReferenceNode(node, checker) {
    if (typescript_1.isTypeReferenceNode(node)) {
        return resolveTypeReference(node, checker);
    }
    if (typescript_1.isExpressionWithTypeArguments(node)) {
        return ts_utils_1.getSymbolDecalartions(checker.getSymbolAtLocation(node.expression), checker);
    }
    return [];
}
function resolveTypeReference(typeNode, checker) {
    var parameterDeclaration = type_resolving_1.getGenericParameterDeclaration(typeNode, checker);
    if (parameterDeclaration) {
        return [parameterDeclaration];
    }
    if (typescript_1.isIdentifier(typeNode.typeName)) {
        var symbol = checker.getSymbolAtLocation(typeNode.typeName);
        return ts_utils_1.getSymbolDecalartions(symbol, checker);
    }
    return [];
}
//# sourceMappingURL=bundler.js.map