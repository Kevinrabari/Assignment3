"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeTags = exports.getSymbolType = exports.getFullyQualifiedName = exports.getSymbolTags = exports.hasTag = exports.buildMemberTags = exports.getSignatureDeclarationTags = exports.normalizeTag = void 0;
var typescript_1 = require("typescript");
var type_resolving_1 = require("./type-resolving");
var ts_utils_1 = require("./ts-utils");
var logging_1 = require("../logging");
function normalizeTag(tag) {
    return { name: tag.tagName.text, value: tag.comment };
}
exports.normalizeTag = normalizeTag;
function getSignatureDeclarationTags(checker, declaration, baseDir) {
    return getSymbolTags(checker, checker.getTypeAtLocation(declaration).getSymbol(), baseDir, checker.getSignatureFromDeclaration(declaration));
}
exports.getSignatureDeclarationTags = getSignatureDeclarationTags;
function buildMemberTags(rawDocTags) {
    var _a;
    var tags = {};
    var normalizedTags = [];
    for (var k = 0; k < rawDocTags.length; k += 1) {
        var tag = rawDocTags[k];
        if (tag.name === 'name')
            continue;
        if (tag.name === '' && k > 0) {
            var prevTag = normalizedTags[k - 1];
            prevTag.value = prevTag.value + "@" + tag.value;
            continue;
        }
        normalizedTags.push({
            name: convertName(tag.name),
            value: (_a = tag.value) !== null && _a !== void 0 ? _a : '',
        });
    }
    for (var _i = 0, _b = normalizedTags.sort(function (a, b) { return a.name.localeCompare(b.name); }); _i < _b.length; _i++) {
        var _c = _b[_i], name = _c.name, value = _c.value;
        if (!tags[name])
            tags[name] = [];
        tags[name].push(value);
    }
    if (tags.deprecated) {
        var emptyValueIndex = tags.deprecated.indexOf('');
        if (emptyValueIndex >= 0)
            tags.deprecated.splice(emptyValueIndex, 1);
    }
    if (tags.docid && tags.docid.length > 1)
        throw new Error("Multiple docid values are not allowed: " + JSON.stringify(tags.docid));
    return tags;
}
exports.buildMemberTags = buildMemberTags;
function convertName(name) {
    if (name === 'publicName')
        return 'name';
    return name;
}
function hasTag(symbol, tagName) {
    return symbol.getJsDocTags().find(function (t) { return t.name === tagName; }) !== undefined;
}
exports.hasTag = hasTag;
function getSymbolTags(checker, symbol, baseDir, signature) {
    var _a;
    var tags = getJsDocTags(signature, symbol);
    var hasTypeTag = tags.find(function (t) { return t.name === 'type'; });
    var idTag = tags.find(function (t) { return t.name === 'docid' || t.name === 'const'; });
    if (!idTag)
        return [];
    idTag.value = (_a = idTag.value) !== null && _a !== void 0 ? _a : getFullyQualifiedName(symbol);
    var generatedTags = generateTags(signature, symbol, checker, baseDir)
        .filter(function (t) { return !hasTypeTag || t.name !== 'acceptValues'; });
    var reportDuplicate = function (tagName) {
        logging_1.log("\"" + tagName + "\" tag can be deleted", { lvl: 'warn', node: symbol.declarations[0] });
    };
    return mergeTags(tags, generatedTags, reportDuplicate);
}
exports.getSymbolTags = getSymbolTags;
function generateTags(signature, symbol, checker, baseDir) {
    var _a;
    var symbolType = (_a = getSignatureType(signature, checker, baseDir)) !== null && _a !== void 0 ? _a : getSymbolType(symbol, checker, baseDir);
    return symbolType ? [
        generateTypeTag(symbolType),
        generateFunctionTypeTags(symbolType),
        generateAcceptValuesTag(symbolType),
    ].flat() : [];
}
function getJsDocTags(signature, symbol) {
    var tags = (signature || symbol).getJsDocTags().map(function (t) { return ({
        name: t.name,
        value: t.text,
    }); });
    var tagLines = getTagLines(signature, symbol);
    return tags.map(function (t) { return (__assign(__assign({}, t), { line: tagLines[t.name] })); });
}
function getTagLines(signature, symbol) {
    var _a, _b;
    var declaration = ((_a = signature === null || signature === void 0 ? void 0 : signature.declaration) !== null && _a !== void 0 ? _a : symbol.declarations[0]);
    if (!(declaration.jsDocCache || declaration.jsDoc))
        return {};
    var sourceFile = declaration.getSourceFile();
    var tagLines = {};
    ((_b = declaration.jsDocCache) !== null && _b !== void 0 ? _b : declaration.jsDoc[0].tags)
        .forEach(function (t) {
        var tagName = t.tagName.escapedText.toString();
        tagLines[tagName] = sourceFile.getLineAndCharacterOfPosition(t.pos).line;
    });
    return tagLines;
}
function getFullyQualifiedName(member) {
    var currentNode = getNamedDeclaration(member.valueDeclaration || member.declarations[0]);
    var nameParts = [getNodeName(currentNode)];
    currentNode = getNamedDeclaration(currentNode.parent);
    while (currentNode) {
        nameParts.push(getNodeName(currentNode));
        currentNode = getNamedDeclaration(currentNode.parent);
    }
    return nameParts.filter(function (p) { return p; }).reverse().join('.');
    function getNodeName(node) {
        return node.name && typescript_1.isIdentifier(node.name) ? node.name.text : undefined;
    }
    function getNamedDeclaration(node) {
        var current = node;
        while (current) {
            if (ts_utils_1.isNamedDeclaration(current)) {
                return current;
            }
            current = current.parent;
        }
        return undefined;
    }
}
exports.getFullyQualifiedName = getFullyQualifiedName;
function getSignatureType(signature, checker, baseDir) {
    var declaration = signature === null || signature === void 0 ? void 0 : signature.declaration;
    if (!declaration)
        return undefined;
    return type_resolving_1.resolveNodeType(declaration, checker, baseDir);
}
function getSymbolType(symbol, checker, baseDir) {
    var ignored = typescript_1.SymbolFlags.Interface | typescript_1.SymbolFlags.Class;
    if (symbol.flags & ignored) {
        return undefined;
    }
    if (symbol.flags & typescript_1.SymbolFlags.Alias) {
        return getSymbolType(checker.getAliasedSymbol(symbol), checker, baseDir);
    }
    var symbolDeclaration = symbol.declarations[0];
    if (ts_utils_1.isNodeWithType(symbolDeclaration) && symbolDeclaration.type !== undefined) {
        return type_resolving_1.resolveNodeType(symbolDeclaration.type, checker, baseDir);
    }
    return type_resolving_1.resolveNodeType(symbolDeclaration, checker, baseDir);
}
exports.getSymbolType = getSymbolType;
function generateTypeTag(memberType) {
    if (type_resolving_1.isFunctionMemberType(memberType) && !memberType.isCallback)
        return [];
    return [{ name: 'type', value: memberType.id }];
}
function generateFunctionTypeTags(memberType) {
    if (type_resolving_1.isFunctionMemberType(memberType)) {
        return getFunctionMemberTags(memberType);
    }
    if (memberType.typeArguments) {
        for (var _i = 0, _a = memberType.typeArguments; _i < _a.length; _i++) {
            var typeArgument = _a[_i];
            var result = generateFunctionTypeTags(typeArgument);
            if (result.length)
                return result;
        }
    }
    return [];
}
function generateAcceptValuesTag(memberType) {
    var _a;
    if ((_a = memberType.typeArguments) === null || _a === void 0 ? void 0 : _a.length) {
        var literalArgs = memberType.typeArguments
            .filter(type_resolving_1.isLiteralMemberType)
            .map(function (t) { return t.value; });
        if (literalArgs.length) {
            return [{ name: 'acceptValues', value: literalArgs.join('|') }];
        }
        for (var _i = 0, _b = memberType.typeArguments; _i < _b.length; _i++) {
            var typeArg = _b[_i];
            var result = generateAcceptValuesTag(typeArg);
            if (result.length)
                return result;
        }
    }
    return [];
}
function getFunctionMemberTags(memberType) {
    var _a;
    var paramTypeTag = memberType.isCallback ? 'type_function_param' : 'param';
    var returnTypeTag = memberType.isCallback ? 'type_function_return' : 'return';
    var result = ((_a = memberType.functionParams) === null || _a === void 0 ? void 0 : _a.length) ? memberType.functionParams.flatMap(function (param, i) { return __spreadArrays([
        paramTag(param, i)
    ], fieldTags(param, i)); })
        : [];
    if (memberType.functionReturnType) {
        result.push({ name: "" + returnTypeTag, value: memberType.functionReturnType });
    }
    return result;
    function paramTag(param, paramIndex) {
        return { name: "" + paramTypeTag + (paramIndex + 1), value: param.id };
    }
    function fieldTags(param, paramIndex) {
        var _a, _b;
        return ((_a = param.fields) === null || _a === void 0 ? void 0 : _a.length) ? (_b = param.fields) === null || _b === void 0 ? void 0 : _b.map(function (field, fieldIndex) { return ({ name: "" + paramTypeTag + (paramIndex + 1) + "_field" + (fieldIndex + 1), value: field }); }) : [];
    }
}
function mergeTags(tags, additionalTags, reportDuplicate) {
    var result = __spreadArrays(tags);
    additionalTags.forEach(function (tag) {
        var tagIndex = result.findIndex(function (t) { return t.name === tag.name; });
        if (tagIndex < 0) {
            result.push(tag);
            return;
        }
        if (result[tagIndex].value === tag.value) {
            reportDuplicate(tag.name);
            result[tagIndex].redundant = true;
        }
    });
    return result;
}
exports.mergeTags = mergeTags;
//# sourceMappingURL=tags.js.map