"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTypeLikeDeclaration = exports.isReadonlyMember = exports.isOptionalMember = exports.getNumberLiteralValue = exports.getModuleName = exports.getModule = exports.createProgram = exports.getNodeName = exports.getSymbolDecalartions = exports.getAliasSymbol = exports.getValueType = exports.getNestedSymbols = exports.getTypeSymbols = exports.isOptional = exports.isNamedDeclaration = exports.isNodeWithType = exports.isEnumTypeNode = exports.isObjectType = exports.isTypeReference = exports.isUnionOrIntersectionTypeNode = exports.isUnionOrIntersectionType = exports.isStructuredType = void 0;
var path_1 = require("path");
var typescript_1 = require("typescript");
var utils_1 = require("./utils");
function isStructuredType(type) {
    return type.flags === typescript_1.TypeFlags.Object
        || (type.flags & typescript_1.TypeFlags.UnionOrIntersection) !== 0;
}
exports.isStructuredType = isStructuredType;
function isUnionOrIntersectionType(type) {
    return (type.flags & typescript_1.TypeFlags.UnionOrIntersection) !== 0;
}
exports.isUnionOrIntersectionType = isUnionOrIntersectionType;
function isUnionOrIntersectionTypeNode(node) {
    return typescript_1.isUnionTypeNode(node) || typescript_1.isIntersectionTypeNode(node);
}
exports.isUnionOrIntersectionTypeNode = isUnionOrIntersectionTypeNode;
function isTypeReference(type) {
    return isObjectType(type) && !!(type.objectFlags & typescript_1.ObjectFlags.Reference);
}
exports.isTypeReference = isTypeReference;
function isObjectType(type) {
    return !!(type.flags & typescript_1.TypeFlags.Object);
}
exports.isObjectType = isObjectType;
function isEnumTypeNode(node) {
    function isEnumNode(typeNode) {
        if (!typescript_1.isUnionTypeNode(typeNode)) {
            return false;
        }
        var literals = typeNode.types.filter(typescript_1.isLiteralTypeNode).map(function (nd) { return nd.literal; });
        return (literals.length === typeNode.types.length
            && (literals.every(typescript_1.isNumericLiteral) || literals.every(typescript_1.isStringLiteral)));
    }
    return isEnumNode(node) || (isNodeWithType(node) && isEnumNode(node.type));
}
exports.isEnumTypeNode = isEnumTypeNode;
function isNodeWithType(node) {
    switch (node.kind) {
        case typescript_1.SyntaxKind.GetAccessor:
        case typescript_1.SyntaxKind.Parameter:
        case typescript_1.SyntaxKind.PropertyDeclaration:
        case typescript_1.SyntaxKind.PropertySignature:
        case typescript_1.SyntaxKind.TypeAliasDeclaration:
        case typescript_1.SyntaxKind.VariableDeclaration:
            return true;
    }
    return false;
}
exports.isNodeWithType = isNodeWithType;
function isNamedDeclaration(node) {
    switch (node.kind) {
        case typescript_1.SyntaxKind.PropertySignature:
        case typescript_1.SyntaxKind.PropertyDeclaration:
        case typescript_1.SyntaxKind.MethodSignature:
        case typescript_1.SyntaxKind.MethodDeclaration:
        case typescript_1.SyntaxKind.GetAccessor:
        case typescript_1.SyntaxKind.SetAccessor:
        case typescript_1.SyntaxKind.VariableDeclaration:
        case typescript_1.SyntaxKind.FunctionDeclaration:
        case typescript_1.SyntaxKind.ClassDeclaration:
        case typescript_1.SyntaxKind.InterfaceDeclaration:
        case typescript_1.SyntaxKind.TypeAliasDeclaration:
        case typescript_1.SyntaxKind.TypeParameter:
            return true;
    }
    return false;
}
exports.isNamedDeclaration = isNamedDeclaration;
function isOptional(symbol) {
    return !!(symbol.flags & typescript_1.SymbolFlags.Optional);
}
exports.isOptional = isOptional;
function getTypeSymbols(type) {
    var _a;
    if (isUnionOrIntersectionType(type)) {
        return type.types.map(getTypeSymbols).flat();
    }
    if (isTypeReference(type) && ((_a = type.target.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'Array' && type.typeArguments.length === 1) {
        return getTypeSymbols(type.typeArguments[0]);
    }
    return type.symbol ? [type.symbol] : [];
}
exports.getTypeSymbols = getTypeSymbols;
function getNestedSymbols(type) {
    var _a, _b, _c;
    var nestedSymbols = __spreadArrays(type.getProperties());
    var staticMethods = (_c = utils_1.toArray((_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.values())) === null || _c === void 0 ? void 0 : _c.filter(function (s) { return !(s.flags & typescript_1.SymbolFlags.Prototype); });
    if (staticMethods)
        nestedSymbols.push.apply(nestedSymbols, staticMethods);
    return nestedSymbols;
}
exports.getNestedSymbols = getNestedSymbols;
function getValueType(kind) {
    switch (kind) {
        case typescript_1.SyntaxKind.BooleanKeyword:
            return 'boolean';
        case typescript_1.SyntaxKind.NumberKeyword:
            return 'number';
        case typescript_1.SyntaxKind.StringKeyword:
            return 'string';
        case typescript_1.SyntaxKind.AnyKeyword:
            return 'any';
        case typescript_1.SyntaxKind.ObjectKeyword:
        case typescript_1.SyntaxKind.TypeLiteral:
            return 'object';
        case typescript_1.SyntaxKind.VoidKeyword:
            return 'void';
        case typescript_1.SyntaxKind.NeverKeyword:
            return 'never';
        case typescript_1.SyntaxKind.UndefinedKeyword:
            return 'undefined';
        case typescript_1.SyntaxKind.UnknownKeyword:
            return 'unknown';
    }
    return undefined;
}
exports.getValueType = getValueType;
function getAliasSymbol(symbol, checker) {
    return ((symbol === null || symbol === void 0 ? void 0 : symbol.flags) & typescript_1.SymbolFlags.Alias
        ? checker.getAliasedSymbol(symbol)
        : symbol);
}
exports.getAliasSymbol = getAliasSymbol;
function getSymbolDecalartions(symbol, checker) {
    var _a, _b;
    return (_b = ((symbol === null || symbol === void 0 ? void 0 : symbol.flags) & typescript_1.SymbolFlags.Alias
        ? (_a = checker.getAliasedSymbol(symbol)) === null || _a === void 0 ? void 0 : _a.getDeclarations() : symbol === null || symbol === void 0 ? void 0 : symbol.getDeclarations())) !== null && _b !== void 0 ? _b : [];
}
exports.getSymbolDecalartions = getSymbolDecalartions;
function getNodeName(node) {
    var targetNode = getTargetNode(node);
    if (!targetNode) {
        throw new Error('Cannot get node name: unknown node type');
    }
    return getName(targetNode);
    function getTargetNode(nd) {
        if (typescript_1.isExpressionWithTypeArguments(nd)) {
            return nd.expression;
        }
        if (typescript_1.isTypeReferenceNode(nd)) {
            return nd.typeName;
        }
        if (isNamedDeclaration(nd)) {
            return nd.name;
        }
        return undefined;
    }
    function getName(srcNode) {
        return (srcNode && typescript_1.isIdentifier(srcNode) && srcNode.text) || undefined;
    }
}
exports.getNodeName = getNodeName;
function isStringArray(array) {
    return typeof array[0] === 'string';
}
function createProgram(files) {
    if (isStringArray(files)) {
        return typescript_1.createProgram(files, {});
    }
    return createProgramInMemory(files);
}
exports.createProgram = createProgram;
function createProgramInMemory(sourceFiles) {
    var rootNames = sourceFiles.map(function (file) { return file.fileName; });
    var host = typescript_1.createCompilerHost({});
    var getSourceFile = host.getSourceFile.bind(host);
    host.getSourceFile = function (fileName) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var file = sourceFiles.find(function (f) { return path_1.normalize(f.fileName) === path_1.normalize(fileName); });
        return file !== null && file !== void 0 ? file : getSourceFile.apply(void 0, __spreadArrays([fileName], rest));
    };
    return typescript_1.createProgram(rootNames, {}, host);
}
function getModule(node, baseDir) {
    var modulePath = node.getSourceFile().fileName;
    return getModuleName(modulePath, baseDir);
}
exports.getModule = getModule;
function getModuleName(filePath, baseDir) {
    var _a;
    return (_a = utils_1.getInnerPath(filePath, baseDir)) === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/').replace(/(\.d)?\.tsx?$/, '');
}
exports.getModuleName = getModuleName;
function getNumberLiteralValue(node) {
    var literal = node.literal;
    if (typescript_1.isNumericLiteral(literal)) {
        return +node.literal.getText();
    }
    if (typescript_1.isPrefixUnaryExpression(literal)) {
        var text = literal.operand.getText();
        if (literal.operator === typescript_1.SyntaxKind.MinusToken) {
            return -text;
        }
    }
    return undefined;
}
exports.getNumberLiteralValue = getNumberLiteralValue;
function isObjectMemberDeclaration(declaration) {
    return typescript_1.isPropertyDeclaration(declaration)
        || typescript_1.isPropertySignature(declaration)
        || typescript_1.isMethodDeclaration(declaration)
        || typescript_1.isMethodSignature(declaration);
}
function isOptionalMember(declaration) {
    return isObjectMemberDeclaration(declaration) && !!declaration.questionToken;
}
exports.isOptionalMember = isOptionalMember;
function isReadonlyMember(declaration) {
    var _a;
    return (isObjectMemberDeclaration(declaration) || typescript_1.isIdentifier(declaration))
        && !!((_a = declaration.modifiers) === null || _a === void 0 ? void 0 : _a.some(function (m) { return m.kind === typescript_1.SyntaxKind.ReadonlyKeyword; }));
}
exports.isReadonlyMember = isReadonlyMember;
function isTypeLikeDeclaration(node) {
    return node !== undefined && (typescript_1.isTypeAliasDeclaration(node)
        || typescript_1.isInterfaceDeclaration(node)
        || typescript_1.isClassDeclaration(node)
        || typescript_1.isTypeReferenceNode(node));
}
exports.isTypeLikeDeclaration = isTypeLikeDeclaration;
//# sourceMappingURL=ts-utils.js.map