"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveType = exports.getNodeId = exports.isPublicType = exports.getTypeSymbol = exports.getTsTypes = exports.createTypeProcessor = exports.getId = void 0;
var typescript_1 = require("typescript");
var path_1 = require("path");
var tags_1 = require("./tags");
var utils_1 = require("./utils");
var type_resolving_1 = require("./type-resolving");
var ts_utils_1 = require("./ts-utils");
var data_model_1 = require("../discoverer/data-model");
var logging_1 = require("../logging");
var common_resolving_1 = require("./common-resolving");
function getId(name, module) {
    return module ? module + "." + name : name;
}
exports.getId = getId;
var utilityTypes = new Set(['Pick', 'Omit']);
function createTypeProcessor(checker, baseDir) {
    var visitedMembers = new Set();
    return function (member, tsTypes) { return processTypes(member, tsTypes, checker, baseDir, visitedMembers); };
}
exports.createTypeProcessor = createTypeProcessor;
function processTypes(member, tsTypes, checker, baseDir, visitedMembers) {
    var _a, _b;
    var declaration = member.declarations[0];
    if (isExternalDeclaration(declaration))
        return;
    if ((checker.getTypeAtLocation(declaration).flags === typescript_1.TypeFlags.Any)) {
        return;
    }
    var fileName = declaration.getSourceFile().fileName;
    var uniqueName = fileName + "." + member.escapedName.toString();
    if (visitedMembers.has(uniqueName))
        return;
    visitedMembers.add(uniqueName);
    for (var _i = 0, _c = Object.entries(getTsTypes(checker, member, baseDir, tsTypes, visitedMembers)); _i < _c.length; _i++) {
        var _d = _c[_i], typeKey = _d[0], typeEntry = _d[1];
        if (!utilityTypes.has(typeKey) && (!tsTypes[typeKey] || typeKey.endsWith("." + member.escapedName))) {
            tsTypes[typeKey] = typeEntry;
        }
    }
    var type = checker.getTypeAtLocation(member.declarations[0]);
    (_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.members) === null || _b === void 0 ? void 0 : _b.forEach(function (m) { return processTypes(m, tsTypes, checker, baseDir, visitedMembers); });
}
function isExternalDeclaration(declaration) {
    return declaration.getSourceFile().fileName.includes('node_modules');
}
function getTsTypes(checker, symbol, baseDir, tsTypes, visitedMembers) {
    var _a;
    var _b, _c, _d, _e;
    var result = {};
    var type = checker.getTypeAtLocation(symbol.declarations[0]);
    if (isExternalDeclaration(symbol.declarations[0])) {
        return result;
    }
    if (type.flags === typescript_1.TypeFlags.Any) {
        return _a = {},
            _a[symbol.escapedName.toString()] = {
                kind: 'object',
                props: {},
            },
            _a;
    }
    if (!ts_utils_1.isTypeLikeDeclaration((_c = (_b = type.aliasSymbol) === null || _b === void 0 ? void 0 : _b.declarations) === null || _c === void 0 ? void 0 : _c[0])
        && !ts_utils_1.isTypeLikeDeclaration((_e = (_d = type.symbol) === null || _d === void 0 ? void 0 : _d.declarations) === null || _e === void 0 ? void 0 : _e[0])) {
        return {};
    }
    var descr = buildTypeDescriptor(type);
    var typeId = getNodeId(descr.declaration, baseDir);
    if (isExternalDeclaration(descr.declaration) && !utilityTypes.has(typeId)) {
        return {};
    }
    add(typeId, descr, false);
    if (typescript_1.isTypeAliasDeclaration(symbol.declarations[0])) {
        var aliasId = getNodeId(symbol.declarations[0], baseDir);
        add(aliasId, descr, utilityTypes.has(typeId));
    }
    var baseTypes = getBaseTypes(type);
    if (!baseTypes) {
        return result;
    }
    for (var _i = 0, baseTypes_1 = baseTypes; _i < baseTypes_1.length; _i++) {
        var baseType = baseTypes_1[_i];
        if (baseType.aliasSymbol !== undefined) {
            processTypes(baseType.aliasSymbol, tsTypes, checker, baseDir, visitedMembers);
        }
        var baseTypeDescr = buildTypeDescriptor(baseType);
        var baseTypeId = getNodeId(baseTypeDescr.declaration, baseDir);
        add(baseTypeId, baseTypeDescr, false);
    }
    return result;
    function add(id, _a, aliasToUtilType) {
        var _b;
        var declaration = _a.declaration, propSymbols = _a.propSymbols;
        if (!typescript_1.isInterfaceDeclaration(declaration)
            && !typescript_1.isClassDeclaration(declaration)
            && !typescript_1.isTypeAliasDeclaration(declaration)) {
            throw new Error('TsType resolver: unexpected declaration type');
        }
        var props = (_b = propSymbols === null || propSymbols === void 0 ? void 0 : propSymbols.filter(function (propSymbol) { return !isIgnoredProp(propSymbol.declarations[0]); })) === null || _b === void 0 ? void 0 : _b.reduce(function (acc, propSymbol) {
            acc[propSymbol.escapedName.toString()] = getPropDeclaration(checker, propSymbol, baseDir, declaration);
            return acc;
        }, {});
        var typeParams = aliasToUtilType
            ? {}
            : { typeParams: getTypeParams(declaration, checker, baseDir) };
        result[id] = __assign({ kind: 'object', props: props }, typeParams);
        function isIgnoredProp(propDeclaration) {
            return typescript_1.isGetAccessorDeclaration(propDeclaration)
                || typescript_1.isParameter(propDeclaration);
        }
    }
}
exports.getTsTypes = getTsTypes;
function buildTypeDescriptor(type) {
    var _a;
    return {
        declaration: (_a = getTypeSymbol(type)) === null || _a === void 0 ? void 0 : _a.declarations[0],
        propSymbols: type.getProperties(),
    };
}
function getTypeSymbol(type) {
    return type.aliasSymbol || type.symbol;
}
exports.getTypeSymbol = getTypeSymbol;
function getTypeParams(typeDeclaration, checker, baseDir) {
    if (!typeDeclaration.typeParameters)
        return undefined;
    var result = {};
    typeDeclaration.typeParameters.forEach(function (p) {
        var typeName = p.name.escapedText.toString();
        var typeDefault = p.default ? resolveType(p.default, checker, baseDir) : undefined;
        result[typeName] = typeDefault || null;
    });
    return result;
}
function getBaseTypes(typeObject) {
    return typeObject.isIntersection()
        ? typeObject.types.filter(function (t) { var _a; return !typescript_1.isTypeLiteralNode((_a = getTypeSymbol(t)) === null || _a === void 0 ? void 0 : _a.declarations[0]); })
        : typeObject.getBaseTypes();
}
function isPublicType(symbol) {
    return tags_1.hasTag(symbol, 'public')
        && !tags_1.hasTag(symbol, 'docid')
        && (typescript_1.isTypeAliasDeclaration(symbol.declarations[0])
            || typescript_1.isInterfaceDeclaration(symbol.declarations[0]));
}
exports.isPublicType = isPublicType;
function getNodeId(node, basedDir) {
    var name = ts_utils_1.getNodeName(node);
    var module = ts_utils_1.getModule(node, basedDir);
    return getId(name, module);
}
exports.getNodeId = getNodeId;
function getPropDeclaration(checker, prop, baseDir, currentDeclaration) {
    var propDeclaration = prop.declarations[0];
    var currentId = getNodeId(currentDeclaration, baseDir);
    if (!typescript_1.isPropertySignature(propDeclaration)
        && !typescript_1.isPropertyDeclaration(propDeclaration)
        && !typescript_1.isMethodSignature(propDeclaration)
        && !typescript_1.isMethodDeclaration(propDeclaration)) {
        var name = prop.escapedName.toString();
        var msg = "TsType resolver: property '" + currentId + "." + name + "' is not a PropertySignature nor MethodSignature";
        logging_1.log(msg, { lvl: 'error', node: propDeclaration });
        throw new Error(msg);
    }
    var parent = propDeclaration.parent;
    var parentId = parent && !typescript_1.isTypeLiteralNode(parent) ? getNodeId(parent, baseDir) : undefined;
    var isInherited = parentId && parentId !== currentId;
    if (isInherited) {
        var type = typescript_1.isPropertySignature(propDeclaration)
            ? getResolvedArgTypeName(prop, propDeclaration, checker, baseDir)
            : undefined;
        return {
            inheritedFrom: parentId,
            type: type !== null && type !== void 0 ? type : resolveType(propDeclaration, checker, baseDir),
        };
    }
    var optional = ts_utils_1.isOptionalMember(propDeclaration) || undefined;
    var readonly = ts_utils_1.isReadonlyMember(propDeclaration) || undefined;
    return {
        type: resolveType(propDeclaration, checker, baseDir),
        optional: optional,
        readonly: readonly,
    };
}
function getResolvedArgTypeName(prop, propDeclaration, checker, baseDir) {
    var _a;
    var propType = checker.getTypeOfSymbolAtLocation(prop, propDeclaration);
    var hasGenericArg = !!type_resolving_1.getGenericParameterDeclaration(propDeclaration.type, checker);
    if (!hasGenericArg)
        return undefined;
    var typeDeclaration = (_a = getTypeSymbol(propType)) === null || _a === void 0 ? void 0 : _a.declarations[0];
    return typeDeclaration
        ? resolveType(typeDeclaration, checker, baseDir)
        : getTypeByFlag(propType.flags);
}
function getTypeByFlag(typeFlags) {
    var id;
    if (typeFlags & typescript_1.TypeFlags.Any)
        id = 'any';
    else if (typeFlags & typescript_1.TypeFlags.String)
        id = 'string';
    else if (typeFlags & typescript_1.TypeFlags.Number)
        id = 'number';
    else if (typeFlags & typescript_1.TypeFlags.Boolean)
        id = 'boolean';
    if (!id)
        throw new Error("Unknown type flag: " + typeFlags);
    return {
        kind: data_model_1.TypingKind.Value,
        id: id,
    };
}
function getTypeRefModule(node, name, baseDir) {
    if (!typescript_1.isTypeReferenceNode(node)
        && !typescript_1.isClassDeclaration(node)
        && !typescript_1.isInterfaceDeclaration(node)) {
        return undefined;
    }
    for (var _i = 0, _a = node.getSourceFile().statements; _i < _a.length; _i++) {
        var s = _a[_i];
        var module_1 = getModuleByImportDeclaration(node, s, name, baseDir)
            || getModuleByNamedDeclaration(node, s, name, baseDir);
        if (module_1)
            return module_1;
    }
    return undefined;
}
function getModuleByImportDeclaration(node, statement, name, baseDir) {
    var _a;
    if (!typescript_1.isImportDeclaration(statement))
        return undefined;
    var importName = getImportName(statement, name);
    if (!importName)
        return undefined;
    var currentFolder = path_1.dirname(node.getSourceFile().fileName);
    var moduleSpecifier = statement.moduleSpecifier.getText().replace(/'/g, '');
    var modulePath = path_1.join(currentFolder, moduleSpecifier);
    return (_a = utils_1.getInnerPath(modulePath, baseDir)) === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/');
}
function getModuleByNamedDeclaration(node, statement, name, baseDir) {
    if (!ts_utils_1.isNamedDeclaration(statement) || statement.name.getText() !== name)
        return undefined;
    return ts_utils_1.getModule(node, baseDir);
}
function getImportName(importDeclaration, name) {
    var _a, _b, _c;
    if (((_b = (_a = importDeclaration.importClause) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.escapedText) === name)
        return name;
    if (!((_c = importDeclaration.importClause) === null || _c === void 0 ? void 0 : _c.namedBindings))
        return undefined;
    var importName;
    importDeclaration.importClause.namedBindings.forEachChild(function (nb) {
        var _a;
        if (typescript_1.isImportSpecifier(nb) && nb.name.escapedText === name) {
            importName = (_a = (nb.propertyName || nb.name)) === null || _a === void 0 ? void 0 : _a.escapedText.toString();
            return true;
        }
        return false;
    });
    return importName;
}
function resolveGenericType(node, checker, baseDir) {
    var _a, _b;
    if (!typescript_1.isTypeReferenceNode(node) || !((_a = node.typeArguments) === null || _a === void 0 ? void 0 : _a.length))
        return undefined;
    var type = checker.getTypeAtLocation(node);
    var name = ts_utils_1.getNodeName(node);
    var args = node.typeArguments.map(function (a) { return resolveType(a, checker, baseDir); });
    var module = (_b = getTypeSymbol(type)) === null || _b === void 0 ? void 0 : _b.declarations.map(function (d) { return ts_utils_1.getModule(d, baseDir); }).find(function (d) { return !!d; });
    var id = getId(name, module);
    var isGenericArgument = !!type_resolving_1.getGenericParameterDeclaration(node, checker);
    return {
        id: id,
        kind: isGenericArgument ? data_model_1.TypingKind.GenericArgument : data_model_1.TypingKind.Reference,
        args: args,
    };
}
function resolveReferenceType(node, checker, baseDir) {
    var _a;
    if (typescript_1.isTypeReferenceNode(node)
        || typescript_1.isClassDeclaration(node)
        || typescript_1.isInterfaceDeclaration(node)
        || typescript_1.isTypeParameterDeclaration(node)) {
        var name = (_a = getDefaultExportedTypeName(checker, node, baseDir)) !== null && _a !== void 0 ? _a : ts_utils_1.getNodeName(node);
        var module_2 = getTypeRefModule(node, name, baseDir);
        var id = getId(name, module_2);
        var isGenericArgument = !!type_resolving_1.getGenericParameterDeclaration(node, checker) || undefined;
        return {
            id: id,
            kind: isGenericArgument ? data_model_1.TypingKind.GenericArgument : data_model_1.TypingKind.Reference,
        };
    }
    return undefined;
}
function getDefaultExportedTypeName(checker, node, baseDir) {
    var symbol = checker.getTypeAtLocation(node).getSymbol();
    if (symbol && symbol.name === 'default') {
        var sourceFile = symbol.getDeclarations()[0].getSourceFile();
        var module_3 = ts_utils_1.getModuleName(sourceFile.fileName, baseDir);
        return module_3 + ".default";
    }
    return undefined;
}
function resolveLiteralType(node) {
    if (!typescript_1.isLiteralTypeNode(node))
        return undefined;
    var literal = node.literal;
    if (typescript_1.isStringLiteral(literal))
        return { value: "'" + literal.text + "'", kind: data_model_1.TypingKind.Literal };
    var numberValue = ts_utils_1.getNumberLiteralValue(node);
    if (numberValue !== undefined) {
        return { value: numberValue, kind: data_model_1.TypingKind.Literal };
    }
    if (node.literal.kind === typescript_1.SyntaxKind.NullKeyword) {
        return { value: null, kind: data_model_1.TypingKind.Literal };
    }
    if (node.literal.kind === typescript_1.SyntaxKind.TrueKeyword) {
        return { value: 'true', kind: data_model_1.TypingKind.Literal };
    }
    if (node.literal.kind === typescript_1.SyntaxKind.FalseKeyword) {
        return { value: 'false', kind: data_model_1.TypingKind.Literal };
    }
    throw new Error('Unknown literal type');
}
function resolveUnionOrIntersectionType(node, checker, baseDir) {
    if (!ts_utils_1.isUnionOrIntersectionTypeNode(node))
        return undefined;
    return {
        kind: typescript_1.isUnionTypeNode(node) ? data_model_1.TypingKind.Union : data_model_1.TypingKind.Intersection,
        types: node.types.map(function (t) { return resolveType(t, checker, baseDir); }),
    };
}
function resolveFunctionType(node, checker, baseDir) {
    if (!typescript_1.isFunctionTypeNode(node)
        && !typescript_1.isFunctionDeclaration(node)
        && !typescript_1.isMethodSignature(node)
        && !typescript_1.isMethodDeclaration(node))
        return undefined;
    var params = {};
    node.parameters.forEach(function (p) {
        var name = p.name.getText();
        params[name] = {
            type: resolveType(p.type, checker, baseDir),
            spread: !!p.dotDotDotToken || undefined,
        };
    });
    var returnType = resolveType(node.type, checker, baseDir);
    return {
        kind: data_model_1.TypingKind.Function,
        params: params,
        returnType: returnType,
    };
}
function resolveArrayType(node, checker, baseDir) {
    if (!typescript_1.isArrayTypeNode(node))
        return undefined;
    var result = resolveType(node.elementType, checker, baseDir);
    result.array = true;
    return result;
}
function resolvePropertyType(node, checker, baseDir) {
    if (!typescript_1.isPropertySignature(node)
        && !typescript_1.isPropertyDeclaration(node)) {
        return undefined;
    }
    return resolveType(node.type, checker, baseDir);
}
function resolveThisType(node, checker, baseDir) {
    var _a, _b, _c;
    if (!typescript_1.isThisTypeNode(node))
        return undefined;
    var declaration = (_c = (_b = (_a = checker.getTypeAtLocation(node)) === null || _a === void 0 ? void 0 : _a.getSymbol()) === null || _b === void 0 ? void 0 : _b.getDeclarations()) === null || _c === void 0 ? void 0 : _c[0];
    return declaration ? resolveType(declaration, checker, baseDir) : undefined;
}
function resolveType(node, checker, baseDir) {
    if (node === undefined) {
        return undefined;
    }
    var result = resolvePropertyType(node, checker, baseDir)
        || resolveGenericType(node, checker, baseDir)
        || resolveUnionOrIntersectionType(node, checker, baseDir)
        || resolveReferenceType(node, checker, baseDir)
        || resolveLiteralType(node)
        || common_resolving_1.resolveValueType(node)
        || resolveType(common_resolving_1.getParenthesizedType(node), checker, baseDir)
        || resolveFunctionType(node, checker, baseDir)
        || resolveArrayType(node, checker, baseDir)
        || resolveThisType(node, checker, baseDir)
        || common_resolving_1.resolveNonSupportedType(node);
    if (!result) {
        logging_1.log('Cannot resolve type', { lvl: 'error', node: node });
        throw new Error("Cannot resolve type. Node kind " + node.kind);
    }
    return result;
}
exports.resolveType = resolveType;
//# sourceMappingURL=ts-type-resolving.js.map