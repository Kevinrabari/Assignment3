{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 22.1.3\r\n * Build date: Mon Jun 13 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { smartFormatter as _format, formatRange } from \"./smart_formatter\";\nimport { patchFontOptions, getVizRangeObject, getLogExt as getLog, raiseToExt as raiseTo, valueOf, rotateBBox, getCategoriesInfo, adjustVisualRange, getAddFunction, convertVisualRangeObject } from \"../core/utils\";\nimport { isDefined, isFunction, isPlainObject, type } from \"../../core/utils/type\";\nimport constants from \"./axes_constants\";\nimport { extend } from \"../../core/utils/extend\";\nimport formatHelper from \"../../format_helper\";\nimport { getParser } from \"../components/parse_utils\";\nimport { tickGenerator } from \"./tick_generator\";\nimport { Translator2D } from \"../translators/translator2d\";\nimport { Range } from \"../translators/range\";\nimport { tick } from \"./tick\";\nimport { adjust } from \"../../core/utils/math\";\nimport dateUtils from \"../../core/utils/date\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport xyMethods from \"./xy_axes\";\nimport * as polarMethods from \"./polar_axes\";\nimport createConstantLine from \"./constant_line\";\nimport createStrip from \"./strip\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\nimport { calculateCanvasMargins, measureLabels } from \"./axes_utils\";\nvar convertTicksToValues = constants.convertTicksToValues;\nvar _math = Math;\nvar _abs = _math.abs;\nvar _max = _math.max;\nvar _min = _math.min;\nvar _isArray = Array.isArray;\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\nvar MAX_GRID_BORDER_ADHENSION = 4;\nvar TOP = constants.top;\nvar BOTTOM = constants.bottom;\nvar LEFT = constants.left;\nvar RIGHT = constants.right;\nvar CENTER = constants.center;\nvar KEEP = \"keep\";\nvar SHIFT = \"shift\";\nvar RESET = \"reset\";\nvar ROTATE = \"rotate\";\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\nvar SCROLL_THRESHOLD = 5;\nvar MIN_BAR_MARGIN = 5;\nvar MAX_MARGIN_VALUE = .8;\nvar dateIntervals = {\n  day: 864e5,\n  week: 6048e5\n};\n\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\n  var _options$workWeek;\n\n  var {\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold\n  } = _ref;\n  return tickGenerator({\n    axisType: options.type,\n    dataType: options.dataType,\n    logBase: options.logarithmBase,\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold,\n    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\n    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\n    numberMultipliers: options.numberMultipliers,\n    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\n    allowDecimals: options.allowDecimals,\n    endOnTick: options.endOnTick,\n    incidentOccurred: incidentOccurred,\n    firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\n    skipTickGeneration: skipTickGeneration,\n    skipCalculationLimits: options.skipCalculationLimits,\n    generateExtraTick: options.generateExtraTick,\n    minTickInterval: options.minTickInterval,\n    rangeIsEmpty: rangeIsEmpty\n  });\n}\n\nfunction createMajorTick(axis, renderer, skippedCategory) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.tick, options.grid, skippedCategory, false);\n}\n\nfunction createMinorTick(axis, renderer) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.minorTick, options.minorGrid);\n}\n\nfunction createBoundaryTick(axis, renderer, isFirst) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, extend({}, options.tick, {\n    visible: options.showCustomBoundaryTicks\n  }), options.grid, void 0, false, isFirst ? -1 : 1);\n}\n\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\n  (elements || []).forEach(e => e[action](actionArgument1, actionArgument2));\n}\n\nfunction initTickCoords(ticks) {\n  callAction(ticks, \"initCoords\");\n}\n\nfunction drawTickMarks(ticks, options) {\n  callAction(ticks, \"drawMark\", options);\n}\n\nfunction drawGrids(ticks, drawLine) {\n  callAction(ticks, \"drawGrid\", drawLine);\n}\n\nfunction updateTicksPosition(ticks, options, animate) {\n  callAction(ticks, \"updateTickPosition\", options, animate);\n}\n\nfunction updateGridsPosition(ticks, animate) {\n  callAction(ticks, \"updateGridPosition\", animate);\n}\n\nfunction cleanUpInvalidTicks(ticks) {\n  var i = ticks.length - 1;\n\n  for (i; i >= 0; i--) {\n    if (!removeInvalidTick(ticks, i)) {\n      break;\n    }\n  }\n\n  for (i = 0; i < ticks.length; i++) {\n    if (removeInvalidTick(ticks, i)) {\n      i--;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction removeInvalidTick(ticks, i) {\n  if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\n    ticks.splice(i, 1);\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateAxisOptions(options) {\n  var _labelOptions$minSpac;\n\n  var labelOptions = options.label;\n  var position = options.position;\n  var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\n  var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\n  var labelPosition = labelOptions.position;\n\n  if (position !== defaultPosition && position !== secondaryPosition) {\n    position = defaultPosition;\n  }\n\n  if (!labelPosition || \"outside\" === labelPosition) {\n    labelPosition = position;\n  } else if (\"inside\" === labelPosition) {\n    labelPosition = {\n      [TOP]: BOTTOM,\n      [BOTTOM]: TOP,\n      [LEFT]: RIGHT,\n      [RIGHT]: LEFT\n    }[position];\n  }\n\n  if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\n    labelPosition = position;\n  }\n\n  if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\n    labelOptions.alignment = {\n      [TOP]: CENTER,\n      [BOTTOM]: CENTER,\n      [LEFT]: RIGHT,\n      [RIGHT]: LEFT\n    }[labelPosition];\n  }\n\n  options.position = position;\n  labelOptions.position = labelPosition;\n  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\n  labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\n  options.type && (options.type = options.type.toLowerCase());\n  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\n  options.valueType && (options.valueType = options.valueType.toLowerCase());\n}\n\nfunction getOptimalAngle(boxes, labelOpt) {\n  var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\n\n  return angle < 45 ? -45 : -90;\n}\n\nfunction updateLabels(ticks, step, func) {\n  ticks.forEach(function (tick, index) {\n    if (tick.getContentContainer()) {\n      if (index % step !== 0) {\n        tick.removeLabel();\n      } else if (func) {\n        func(tick, index);\n      }\n    }\n  });\n}\n\nfunction getZoomBoundValue(optionValue, dataValue) {\n  if (void 0 === optionValue) {\n    return dataValue;\n  } else if (null === optionValue) {\n    return;\n  } else {\n    return optionValue;\n  }\n}\n\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\n  var tickGeneratorOptions = extend({}, options, {\n    endOnTick: true,\n    axisDivisionFactor: axisDivisionFactor,\n    skipCalculationLimits: true,\n    generateExtraTick: true,\n    minTickInterval: minTickInterval\n  });\n  return function (tickInterval, skipTickGeneration, min, max, breaks) {\n    return getTickGenerator(tickGeneratorOptions, _noop, skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({\n      min: min,\n      max: max,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, screenDelta, tickInterval, isDefined(tickInterval), void 0, void 0, void 0, breaks);\n  };\n}\n\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\n  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;\n}\n\nexport var Axis = function (renderSettings) {\n  this._renderer = renderSettings.renderer;\n  this._incidentOccurred = renderSettings.incidentOccurred;\n  this._eventTrigger = renderSettings.eventTrigger;\n  this._stripsGroup = renderSettings.stripsGroup;\n  this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\n  this._labelsAxesGroup = renderSettings.labelsAxesGroup;\n  this._constantLinesGroup = renderSettings.constantLinesGroup;\n  this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\n  this._axesContainerGroup = renderSettings.axesContainerGroup;\n  this._gridContainerGroup = renderSettings.gridGroup;\n  this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\n\n  this._setType(renderSettings.axisType, renderSettings.drawingType);\n\n  this._createAxisGroups();\n\n  this._translator = this._createTranslator();\n  this.isArgumentAxis = renderSettings.isArgumentAxis;\n  this._viewport = {};\n  this._prevDataInfo = {};\n  this._firstDrawing = true;\n  this._initRange = {};\n  this._getTemplate = renderSettings.getTemplate;\n};\nAxis.prototype = {\n  constructor: Axis,\n\n  _drawAxis() {\n    var options = this._options;\n\n    if (!options.visible) {\n      return;\n    }\n\n    this._axisElement = this._createAxisElement();\n\n    this._updateAxisElementPosition();\n\n    this._axisElement.attr({\n      \"stroke-width\": options.width,\n      stroke: options.color,\n      \"stroke-opacity\": options.opacity\n    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);\n  },\n\n  _createPathElement(points, attr, sharpDirection) {\n    return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection);\n  },\n\n  sharp(svgElement) {\n    var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n    return svgElement.sharp(this._getSharpParam(), sharpDirection);\n  },\n\n  customPositionIsAvailable: () => false,\n  getOrthogonalAxis: _noop,\n  getCustomPosition: _noop,\n  getCustomBoundaryPosition: _noop,\n  resolveOverlappingForCustomPositioning: _noop,\n  hasNonBoundaryPosition: () => false,\n  customPositionIsBoundaryOrthogonalAxis: () => false,\n\n  getResolvedBoundaryPosition() {\n    return this.getOptions().position;\n  },\n\n  getAxisSharpDirection() {\n    var position = this.getResolvedBoundaryPosition();\n    return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1;\n  },\n\n  getSharpDirectionByCoords(coords) {\n    var canvas = this._getCanvasStartEnd();\n\n    var maxCoord = Math.max(canvas.start, canvas.end);\n    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1;\n  },\n\n  _getGridLineDrawer: function () {\n    var that = this;\n    return function (tick, gridStyle) {\n      var grid = that._getGridPoints(tick.coords);\n\n      if (grid.points) {\n        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));\n      }\n\n      return null;\n    };\n  },\n  _getGridPoints: function (coords) {\n    var isHorizontal = this._isHorizontal;\n    var tickPositionField = isHorizontal ? \"x\" : \"y\";\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n    var borderOptions = this.borderOptions;\n    var canvasStart = isHorizontal ? LEFT : TOP;\n    var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\n    var axisCanvas = this.getCanvas();\n    var canvas = {\n      left: axisCanvas.left,\n      right: axisCanvas.width - axisCanvas.right,\n      top: axisCanvas.top,\n      bottom: axisCanvas.height - axisCanvas.bottom\n    };\n    var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\n    var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\n    var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\n    var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\n\n    if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\n      return {\n        points: null\n      };\n    }\n\n    return {\n      points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\n    };\n  },\n  _getConstantLinePos: function (parsedValue, canvasStart, canvasEnd) {\n    var value = this._getTranslatedCoord(parsedValue);\n\n    if (!isDefined(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\n      return;\n    }\n\n    return value;\n  },\n  _getConstantLineGraphicAttributes: function (value) {\n    var positionFrom = this._orthogonalPositions.start;\n    var positionTo = this._orthogonalPositions.end;\n    return {\n      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\n    };\n  },\n  _createConstantLine: function (value, attr) {\n    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));\n  },\n  _drawConstantLineLabelText: function (text, x, y, _ref2, group) {\n    var {\n      font: font,\n      cssClass: cssClass\n    } = _ref2;\n    return this._renderer.text(text, x, y).css(patchFontOptions(extend({}, this._options.label.font, font))).attr({\n      align: \"center\",\n      class: cssClass\n    }).append(group);\n  },\n  _drawConstantLineLabels: function (parsedValue, lineLabelOptions, value, group) {\n    var _text;\n\n    var text = lineLabelOptions.text;\n    var options = this._options;\n    var labelOptions = options.label;\n\n    this._checkAlignmentConstantLineLabels(lineLabelOptions);\n\n    text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\n\n    var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\n\n    return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);\n  },\n  _getStripPos: function (startValue, endValue, canvasStart, canvasEnd, range) {\n    var isContinuous = !!(range.minVisible || range.maxVisible);\n    var categories = (range.categories || []).reduce(function (result, cat) {\n      result.push(cat.valueOf());\n      return result;\n    }, []);\n    var start;\n    var end;\n    var swap;\n    var startCategoryIndex;\n    var endCategoryIndex;\n\n    if (!isContinuous) {\n      if (isDefined(startValue) && isDefined(endValue)) {\n        var _parsedStartValue$val, _parsedEndValue$value;\n\n        var parsedStartValue = this.parser(startValue);\n        var parsedEndValue = this.parser(endValue);\n        startCategoryIndex = categories.indexOf(null !== (_parsedStartValue$val = null === parsedStartValue || void 0 === parsedStartValue ? void 0 : parsedStartValue.valueOf()) && void 0 !== _parsedStartValue$val ? _parsedStartValue$val : void 0);\n        endCategoryIndex = categories.indexOf(null !== (_parsedEndValue$value = null === parsedEndValue || void 0 === parsedEndValue ? void 0 : parsedEndValue.valueOf()) && void 0 !== _parsedEndValue$value ? _parsedEndValue$value : void 0);\n\n        if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\n          return {\n            from: 0,\n            to: 0,\n            outOfCanvas: true\n          };\n        }\n\n        if (startCategoryIndex > endCategoryIndex) {\n          swap = endValue;\n          endValue = startValue;\n          startValue = swap;\n        }\n      }\n    }\n\n    if (isDefined(startValue)) {\n      startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\n      start = this._getTranslatedCoord(startValue, -1);\n    } else {\n      start = canvasStart;\n    }\n\n    if (isDefined(endValue)) {\n      endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\n      end = this._getTranslatedCoord(endValue, 1);\n    } else {\n      end = canvasEnd;\n    }\n\n    var stripPosition = start < end ? {\n      from: start,\n      to: end\n    } : {\n      from: end,\n      to: start\n    };\n    var visibleArea = this.getVisibleArea();\n\n    if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\n      stripPosition.outOfCanvas = true;\n    }\n\n    return stripPosition;\n  },\n  _getStripGraphicAttributes: function (fromPoint, toPoint) {\n    var x;\n    var y;\n    var width;\n    var height;\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n\n    if (this._isHorizontal) {\n      x = fromPoint;\n      y = _min(positionFrom, positionTo);\n      width = toPoint - fromPoint;\n      height = _abs(positionFrom - positionTo);\n    } else {\n      x = _min(positionFrom, positionTo);\n      y = fromPoint;\n      width = _abs(positionFrom - positionTo);\n      height = _abs(fromPoint - toPoint);\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  _createStrip: function (attrs) {\n    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);\n  },\n  _adjustStripLabels: function () {\n    var that = this;\n\n    this._strips.forEach(function (strip) {\n      if (strip.label) {\n        strip.label.attr(that._getAdjustedStripLabelCoords(strip));\n      }\n    });\n  },\n\n  _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\n    var getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\n\n    this._majorTicks.forEach(function (tick) {\n      if (tick.label) {\n        tick.updateMultilineTextAlignment();\n        tick.label.attr(getContainerAttrs(tick));\n      } else {\n        tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick));\n      }\n    });\n  },\n\n  _adjustLabels: function (offset) {\n    var options = this.getOptions();\n    var positionsAreConsistent = options.position === options.label.position;\n\n    var maxSize = this._majorTicks.reduce(function (size, tick) {\n      if (!tick.getContentContainer()) {\n        return size;\n      }\n\n      var bBox = tick.labelRotationAngle ? rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\n      return {\n        width: _max(size.width || 0, bBox.width),\n        height: _max(size.height || 0, bBox.height),\n        offset: _max(size.offset || 0, tick.labelOffset || 0)\n      };\n    }, {});\n\n    var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\n\n    this._adjustLabelsCoord(offset, maxSize.width);\n\n    return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0);\n  },\n  _getLabelAdjustedCoord: function (tick, offset, maxWidth) {\n    offset = offset || 0;\n    var options = this._options;\n    var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\n    var box = templateBox || rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\n    var textAlign = tick.labelAlignment || options.label.alignment;\n    var isDiscrete = \"discrete\" === this._options.type;\n    var isFlatLabel = tick.labelRotationAngle % 90 === 0;\n    var indentFromAxis = options.label.indentFromAxis;\n    var labelPosition = options.label.position;\n    var axisPosition = this._axisPosition;\n    var labelCoords = tick.labelCoords;\n    var labelX = labelCoords.x;\n    var translateX;\n    var translateY;\n\n    if (this._isHorizontal) {\n      if (labelPosition === BOTTOM) {\n        translateY = axisPosition + indentFromAxis - box.y + offset;\n      } else {\n        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;\n      }\n\n      if (textAlign === RIGHT) {\n        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;\n      } else if (textAlign === LEFT) {\n        translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;\n      } else {\n        translateX = labelX - box.x - box.width / 2;\n      }\n    } else {\n      translateY = labelCoords.y - box.y - box.height / 2;\n\n      if (labelPosition === LEFT) {\n        if (textAlign === LEFT) {\n          translateX = axisPosition - indentFromAxis - maxWidth - box.x;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition - indentFromAxis - box.x - box.width;\n        }\n\n        translateX -= offset;\n      } else {\n        if (textAlign === RIGHT) {\n          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition + indentFromAxis - box.x;\n        }\n\n        translateX += offset;\n      }\n    }\n\n    return {\n      translateX: translateX,\n      translateY: translateY\n    };\n  },\n  _createAxisConstantLineGroups: function () {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    var constantLinesClass = classSelector + \"constant-lines\";\n    var insideGroup = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup1 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup2 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    return {\n      inside: insideGroup,\n      outside1: outsideGroup1,\n      left: outsideGroup1,\n      top: outsideGroup1,\n      outside2: outsideGroup2,\n      right: outsideGroup2,\n      bottom: outsideGroup2,\n      remove: function () {\n        this.inside.remove();\n        this.outside1.remove();\n        this.outside2.remove();\n      },\n      clear: function () {\n        this.inside.clear();\n        this.outside1.clear();\n        this.outside2.clear();\n      }\n    };\n  },\n  _createAxisGroups: function () {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    this._axisGroup = renderer.g().attr({\n      class: classSelector + \"axis\"\n    }).enableLinks();\n    this._axisStripGroup = renderer.g().attr({\n      class: classSelector + \"strips\"\n    });\n    this._axisGridGroup = renderer.g().attr({\n      class: classSelector + \"grid\"\n    });\n    this._axisElementsGroup = renderer.g().attr({\n      class: classSelector + \"elements\"\n    });\n    this._axisLineGroup = renderer.g().attr({\n      class: classSelector + \"line\"\n    }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\n    this._axisTitleGroup = renderer.g().attr({\n      class: classSelector + \"title\"\n    }).append(this._axisGroup);\n    this._axisConstantLineGroups = {\n      above: this._createAxisConstantLineGroups(),\n      under: this._createAxisConstantLineGroups()\n    };\n    this._axisStripLabelGroup = renderer.g().attr({\n      class: classSelector + \"axis-labels\"\n    });\n  },\n  _clearAxisGroups: function () {\n    this._axisGroup.remove();\n\n    this._axisStripGroup.remove();\n\n    this._axisStripLabelGroup.remove();\n\n    this._axisConstantLineGroups.above.remove();\n\n    this._axisConstantLineGroups.under.remove();\n\n    this._axisGridGroup.remove();\n\n    this._axisTitleGroup.clear();\n\n    if (!this._options.label.template || !this.isRendered()) {\n      this._axisElementsGroup.remove();\n\n      this._axisElementsGroup.clear();\n    }\n\n    this._axisLineGroup && this._axisLineGroup.clear();\n    this._axisStripGroup && this._axisStripGroup.clear();\n    this._axisGridGroup && this._axisGridGroup.clear();\n\n    this._axisConstantLineGroups.above.clear();\n\n    this._axisConstantLineGroups.under.clear();\n\n    this._axisStripLabelGroup && this._axisStripLabelGroup.clear();\n  },\n  _getLabelFormatObject: function (value, labelOptions, range, point, tickInterval, ticks) {\n    range = range || this._getViewportRange();\n    var formatObject = {\n      value: value,\n      valueText: _format(value, {\n        labelOptions: labelOptions,\n        ticks: ticks || convertTicksToValues(this._majorTicks),\n        tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\n        dataType: this._options.dataType,\n        logarithmBase: this._options.logarithmBase,\n        type: this._options.type,\n        showTransition: !this._options.marker.visible,\n        point: point\n      }) || \"\",\n      min: range.minVisible,\n      max: range.maxVisible\n    };\n\n    if (point) {\n      formatObject.point = point;\n    }\n\n    return formatObject;\n  },\n  formatLabel: function (value, labelOptions, range, point, tickInterval, ticks) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\n\n    return isFunction(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;\n  },\n  formatHint: function (value, labelOptions, range) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range);\n\n    return isFunction(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0;\n  },\n\n  formatRange(startValue, endValue, interval, argumentFormat) {\n    return formatRange({\n      startValue: startValue,\n      endValue: endValue,\n      tickInterval: interval,\n      argumentFormat: argumentFormat,\n      axisOptions: this.getOptions()\n    });\n  },\n\n  _setTickOffset: function () {\n    var options = this._options;\n    var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\n    this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode);\n  },\n\n  aggregatedPointBetweenTicks() {\n    return \"crossTicks\" === this._options.aggregatedPointsPosition;\n  },\n\n  resetApplyingAnimation: function (isFirstDrawing) {\n    this._resetApplyingAnimation = true;\n\n    if (isFirstDrawing) {\n      this._firstDrawing = true;\n    }\n  },\n\n  isFirstDrawing() {\n    return this._firstDrawing;\n  },\n\n  getMargins: function () {\n    var that = this;\n    var {\n      position: position,\n      offset: offset,\n      customPosition: customPosition,\n      placeholderSize: placeholderSize,\n      grid: grid,\n      tick: tick,\n      crosshairMargin: crosshairMargin\n    } = that._options;\n    var isDefinedCustomPositionOption = isDefined(customPosition);\n    var boundaryPosition = that.getResolvedBoundaryPosition();\n    var canvas = that.getCanvas();\n    var cLeft = canvas.left;\n    var cTop = canvas.top;\n    var cRight = canvas.width - canvas.right;\n    var cBottom = canvas.height - canvas.bottom;\n\n    var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\n\n    var constantLineAboveSeries = that._axisConstantLineGroups.above;\n    var constantLineUnderSeries = that._axisConstantLineGroups.under;\n    var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function (group) {\n      var box = group && group.getBBox();\n\n      if (!box || box.isEmpty) {\n        return box;\n      }\n\n      if (that._isHorizontal) {\n        box.x = cLeft;\n        box.width = cRight - cLeft;\n      } else {\n        box.y = cTop;\n        box.height = cBottom - cTop;\n      }\n\n      return box;\n    }(that._axisTitleGroup));\n    var margins = calculateCanvasMargins(boxes, canvas);\n    margins[position] += crosshairMargin;\n\n    if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\n      margins[boundaryPosition] = 0;\n    }\n\n    if (placeholderSize) {\n      margins[position] = placeholderSize;\n    }\n\n    if (edgeMarginCorrection) {\n      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\n        margins.right = edgeMarginCorrection;\n      }\n\n      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\n        margins.bottom = edgeMarginCorrection;\n      }\n    }\n\n    if (!isDefinedCustomPositionOption && isDefined(offset)) {\n      var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\n      margins[boundaryPosition] -= moveByOffset ? offset : 0;\n    }\n\n    return margins;\n  },\n  validateUnit: function (unit, idError, parameters) {\n    unit = this.parser(unit);\n\n    if (void 0 === unit && idError) {\n      this._incidentOccurred(idError, [parameters]);\n    }\n\n    return unit;\n  },\n  _setType: function (axisType, drawingType) {\n    var axisTypeMethods;\n\n    switch (axisType) {\n      case \"xyAxes\":\n        axisTypeMethods = xyMethods;\n        break;\n\n      case \"polarAxes\":\n        axisTypeMethods = polarMethods;\n    }\n\n    extend(this, axisTypeMethods[drawingType]);\n  },\n  _getSharpParam: function () {\n    return true;\n  },\n  _disposeBreaksGroup: _noop,\n  dispose: function () {\n    [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach(function (g) {\n      g.dispose();\n    });\n    this._strips = this._title = null;\n    this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\n    this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\n    this._axisGroup = this._axisTitleGroup = null;\n    this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\n    this._renderer = this._options = this._textOptions = this._textFontStyles = null;\n    this._translator = null;\n    this._majorTicks = this._minorTicks = null;\n\n    this._disposeBreaksGroup();\n\n    this._templatesRendered && this._templatesRendered.reject();\n  },\n  getOptions: function () {\n    return this._options;\n  },\n  setPane: function (pane) {\n    this.pane = pane;\n    this._options.pane = pane;\n  },\n  setTypes: function (type, axisType, typeSelector) {\n    this._options.type = type || this._options.type;\n    this._options[typeSelector] = axisType || this._options[typeSelector];\n\n    this._updateTranslator();\n  },\n  resetTypes: function (typeSelector) {\n    this._options.type = this._initTypes.type;\n    this._options[typeSelector] = this._initTypes[typeSelector];\n  },\n  getTranslator: function () {\n    return this._translator;\n  },\n  updateOptions: function (options) {\n    var that = this;\n    var labelOpt = options.label;\n    validateAxisOptions(options);\n    that._options = options;\n    options.tick = options.tick || {};\n    options.minorTick = options.minorTick || {};\n    options.grid = options.grid || {};\n    options.minorGrid = options.minorGrid || {};\n    options.title = options.title || {};\n    options.marker = options.marker || {};\n    that._initTypes = {\n      type: options.type,\n      argumentType: options.argumentType,\n      valueType: options.valueType\n    };\n\n    that._setTickOffset();\n\n    that._isHorizontal = options.isHorizontal;\n    that.pane = options.pane;\n    that.name = options.name;\n    that.priority = options.priority;\n    that._hasLabelFormat = \"\" !== labelOpt.format && isDefined(labelOpt.format);\n    that._textOptions = {\n      opacity: labelOpt.opacity,\n      align: \"center\",\n      class: labelOpt.cssClass\n    };\n    that._textFontStyles = patchFontOptions(labelOpt.font);\n\n    if (options.type === constants.logarithmic) {\n      if (options.logarithmBaseError) {\n        that._incidentOccurred(\"E2104\");\n\n        delete options.logarithmBaseError;\n      }\n    }\n\n    that._updateTranslator();\n\n    that._createConstantLines();\n\n    that._strips = (options.strips || []).map(o => createStrip(that, o));\n    that._majorTicks = that._minorTicks = null;\n    that._firstDrawing = true;\n  },\n  calculateInterval: function (value, prevValue) {\n    var options = this._options;\n\n    if (!options || options.type !== constants.logarithmic) {\n      return _abs(value - prevValue);\n    }\n\n    var {\n      allowNegatives: allowNegatives,\n      linearThreshold: linearThreshold\n    } = new Range(this.getTranslator().getBusinessRange());\n    return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold));\n  },\n\n  getCanvasRange() {\n    var translator = this._translator;\n    return {\n      startValue: translator.from(translator.translate(\"canvas_position_start\")),\n      endValue: translator.from(translator.translate(\"canvas_position_end\"))\n    };\n  },\n\n  _processCanvas: function (canvas) {\n    return canvas;\n  },\n  updateCanvas: function (canvas, canvasRedesign) {\n    if (!canvasRedesign) {\n      var positions = this._orthogonalPositions = {\n        start: !this._isHorizontal ? canvas.left : canvas.top,\n        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\n      };\n      positions.center = positions.start + (positions.end - positions.start) / 2;\n    } else {\n      this._orthogonalPositions = null;\n    }\n\n    this._canvas = canvas;\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    this._initAxisPositions();\n  },\n  getCanvas: function () {\n    return this._canvas;\n  },\n\n  getAxisShift() {\n    return this._axisShift || 0;\n  },\n\n  hideTitle: function () {\n    if (this._options.title.text) {\n      this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisTitleGroup.clear();\n    }\n  },\n  getTitle: function () {\n    return this._title;\n  },\n  hideOuterElements: function () {\n    var options = this._options;\n\n    if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\n      this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisElementsGroup.clear();\n\n      callAction(this._outsideConstantLines, \"removeLabel\");\n    }\n  },\n\n  _resolveLogarithmicOptionsForRange(range) {\n    var options = this._options;\n\n    if (options.type === constants.logarithmic) {\n      range.addRange({\n        allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\n      });\n\n      if (!isNaN(options.linearThreshold)) {\n        range.linearThreshold = options.linearThreshold;\n      }\n    }\n  },\n\n  adjustViewport(businessRange) {\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n    var categories = this._seriesData && this._seriesData.categories || [];\n    var wholeRange = this.adjustRange(getVizRangeObject(options.wholeRange));\n    var visualRange = this.getViewport() || {};\n    var result = new Range(businessRange);\n\n    this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\n\n    var minDefined = isDefined(visualRange.startValue);\n    var maxDefined = isDefined(visualRange.endValue);\n\n    if (!isDiscrete) {\n      minDefined = minDefined && (!isDefined(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\n      maxDefined = maxDefined && (!isDefined(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);\n    }\n\n    var minVisible = minDefined ? visualRange.startValue : result.minVisible;\n    var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\n\n    if (!isDiscrete) {\n      var _wholeRange$startValu, _wholeRange$endValue;\n\n      result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\n      result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max;\n    } else {\n      var categoriesInfo = getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\n      categories = categoriesInfo.categories;\n      result.categories = categories;\n    }\n\n    var adjustedVisualRange = adjustVisualRange({\n      axisType: options.type,\n      dataType: options.dataType,\n      base: options.logarithmBase\n    }, {\n      startValue: minDefined ? visualRange.startValue : void 0,\n      endValue: maxDefined ? visualRange.endValue : void 0,\n      length: visualRange.length\n    }, {\n      categories: categories,\n      min: wholeRange.startValue,\n      max: wholeRange.endValue\n    }, {\n      categories: categories,\n      min: minVisible,\n      max: maxVisible\n    });\n    result.minVisible = adjustedVisualRange.startValue;\n    result.maxVisible = adjustedVisualRange.endValue;\n    !isDefined(result.min) && (result.min = result.minVisible);\n    !isDefined(result.max) && (result.max = result.maxVisible);\n    result.addRange({});\n\n    this._resolveLogarithmicOptionsForRange(result);\n\n    return result;\n  },\n\n  adjustRange(range) {\n    range = range || {};\n    var isDiscrete = this._options.type === constants.discrete;\n    var isLogarithmic = this._options.type === constants.logarithmic;\n    var disabledNegatives = false === this._options.allowNegatives;\n\n    if (isLogarithmic) {\n      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\n      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;\n    }\n\n    if (!isDiscrete && isDefined(range.startValue) && isDefined(range.endValue) && range.startValue > range.endValue) {\n      var tmp = range.endValue;\n      range.endValue = range.startValue;\n      range.startValue = tmp;\n    }\n\n    return range;\n  },\n\n  _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\n    var value = this._options.visualRangeUpdateMode;\n    var translator = this._translator;\n    var range = this._seriesData;\n    var prevDataInfo = this._prevDataInfo;\n\n    if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {\n      return KEEP;\n    }\n\n    if (!this.isArgumentAxis) {\n      var _viewport = this.getViewport();\n\n      if (!isDefined(_viewport.startValue) && !isDefined(_viewport.endValue) && !isDefined(_viewport.length)) {\n        return RESET;\n      }\n    }\n\n    if (this.isArgumentAxis) {\n      if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\n        if (range.axisType === constants.discrete) {\n          var categories = range.categories;\n          var newCategories = newRange.categories;\n          var visualRange = this.visualRange();\n\n          if (categories && newCategories && categories.length && -1 !== newCategories.map(c => c.valueOf()).join(\",\").indexOf(categories.map(c => c.valueOf()).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\n            value = KEEP;\n          } else {\n            value = RESET;\n          }\n        } else {\n          var minPoint = translator.translate(range.min);\n          var minVisiblePoint = translator.translate(viewport.startValue);\n          var maxPoint = translator.translate(range.max);\n          var maxVisiblePoint = translator.translate(viewport.endValue);\n\n          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = RESET;\n          } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = SHIFT;\n          } else {\n            value = KEEP;\n          }\n        }\n\n        if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {\n          value = RESET;\n        }\n      }\n    } else if (-1 === [KEEP, RESET].indexOf(value)) {\n      if (oppositeValue === KEEP) {\n        value = KEEP;\n      } else {\n        value = RESET;\n      }\n    }\n\n    return value;\n  },\n\n  _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\n    var visualRange = this.visualRange();\n\n    if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\n      return;\n    }\n\n    var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\n\n    if (visualRangeUpdateMode === KEEP) {\n      this._setVisualRange([visualRange.startValue, visualRange.endValue]);\n    } else if (visualRangeUpdateMode === RESET) {\n      this._setVisualRange([null, null]);\n    } else if (visualRangeUpdateMode === SHIFT) {\n      this._setVisualRange({\n        length: this.getVisualRangeLength()\n      });\n    }\n  },\n\n  getVisualRangeLength(range) {\n    var currentBusinessRange = range || this._translator.getBusinessRange();\n\n    var {\n      type: type\n    } = this._options;\n    var length;\n\n    if (type === constants.logarithmic) {\n      length = adjust(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      length = categoriesInfo.categories.length;\n    } else {\n      length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;\n    }\n\n    return length;\n  },\n\n  getVisualRangeCenter(range, useMerge) {\n    var translator = this.getTranslator();\n    var businessRange = translator.getBusinessRange();\n    var currentBusinessRange = useMerge ? extend(true, {}, businessRange, range || {}) : range || businessRange;\n    var {\n      type: type,\n      logarithmBase: logarithmBase\n    } = this._options;\n    var center;\n\n    if (!isDefined(currentBusinessRange.minVisible) || !isDefined(currentBusinessRange.maxVisible)) {\n      return;\n    }\n\n    if (type === constants.logarithmic) {\n      var {\n        allowNegatives: allowNegatives,\n        linearThreshold: linearThreshold,\n        minVisible: minVisible,\n        maxVisible: maxVisible\n      } = currentBusinessRange;\n      center = raiseTo(adjust(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\n      center = businessRange.categories.indexOf(categoriesInfo.categories[index]);\n    } else {\n      center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2);\n    }\n\n    return center;\n  },\n\n  setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\n    var _that$_seriesData$min, _that$_seriesData$max;\n\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n\n    this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\n\n    this._seriesData = new Range(range);\n\n    var dataIsEmpty = this._seriesData.isEmpty();\n\n    var rangeWithConstantLines = new Range(this._seriesData);\n\n    this._addConstantLinesToRange(rangeWithConstantLines, \"minVisible\", \"maxVisible\");\n\n    this._prevDataInfo = {\n      isEmpty: dataIsEmpty,\n      containsConstantLine: rangeWithConstantLines.containsConstantLine\n    };\n\n    this._seriesData.addRange({\n      categories: options.categories,\n      dataType: options.dataType,\n      axisType: options.type,\n      base: options.logarithmBase,\n      invert: options.inverted\n    });\n\n    this._resolveLogarithmicOptionsForRange(this._seriesData);\n\n    if (!isDiscrete) {\n      if (!isDefined(this._seriesData.min) && !isDefined(this._seriesData.max)) {\n        var visualRange = this.getViewport();\n        visualRange && this._seriesData.addRange({\n          min: visualRange.startValue,\n          max: visualRange.endValue\n        });\n      }\n\n      var synchronizedValue = options.synchronizedValue;\n\n      if (isDefined(synchronizedValue)) {\n        this._seriesData.addRange({\n          min: synchronizedValue,\n          max: synchronizedValue\n        });\n      }\n    }\n\n    this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\n    this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\n\n    if (!this.isArgumentAxis && options.showZero) {\n      this._seriesData.correctValueZeroLevel();\n    }\n\n    this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\n\n    this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n\n  _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {\n      if (cl.options.extendAxis) {\n        var value = cl.getParsedValue();\n        dataRange.addRange({\n          containsConstantLine: true,\n          [minValueField]: value,\n          [maxValueField]: value\n        });\n      }\n    });\n  },\n\n  setGroupSeries: function (series) {\n    this._series = series;\n  },\n  getLabelsPosition: function () {\n    var options = this._options;\n    var position = options.position;\n    var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\n    var axisPosition = this._axisPosition;\n    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;\n  },\n  getFormattedValue: function (value, options, point) {\n    var labelOptions = this._options.label;\n    return isDefined(value) ? this.formatLabel(value, extend(true, {}, labelOptions, options), void 0, point) : null;\n  },\n  _getBoundaryTicks: function (majors, viewPort) {\n    var length = majors.length;\n    var options = this._options;\n    var customBounds = options.customBoundTicks;\n    var min = viewPort.minVisible;\n    var max = viewPort.maxVisible;\n    var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\n    var boundaryTicks = [];\n\n    if (options.type === constants.discrete) {\n      if (this._tickOffset && 0 !== majors.length) {\n        boundaryTicks = [majors[0], majors[majors.length - 1]];\n      }\n    } else if (customBounds) {\n      if (addMinMax.min && isDefined(customBounds[0])) {\n        boundaryTicks.push(customBounds[0]);\n      }\n\n      if (addMinMax.max && isDefined(customBounds[1])) {\n        boundaryTicks.push(customBounds[1]);\n      }\n    } else {\n      if (addMinMax.min && (0 === length || majors[0] > min)) {\n        boundaryTicks.push(min);\n      }\n\n      if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\n        boundaryTicks.push(max);\n      }\n    }\n\n    return boundaryTicks;\n  },\n  setPercentLabelFormat: function () {\n    if (!this._hasLabelFormat) {\n      this._options.label.format = \"percent\";\n    }\n  },\n  resetAutoLabelFormat: function () {\n    if (!this._hasLabelFormat) {\n      delete this._options.label.format;\n    }\n  },\n  getMultipleAxesSpacing: function () {\n    return this._options.multipleAxesSpacing || 0;\n  },\n  getTicksValues: function () {\n    return {\n      majorTicksValues: convertTicksToValues(this._majorTicks),\n      minorTicksValues: convertTicksToValues(this._minorTicks)\n    };\n  },\n  estimateTickInterval: function (canvas) {\n    this.updateCanvas(canvas);\n    return this._tickInterval !== this._getTicks(this._getViewportRange(), _noop, true).tickInterval;\n  },\n  setTicks: function (ticks) {\n    var majors = ticks.majorTicks || [];\n    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\n    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\n    this._isSynchronized = true;\n  },\n  _adjustDivisionFactor: function (val) {\n    return val;\n  },\n  _getTicks: function (viewPort, incidentOccurred, skipTickGeneration) {\n    var options = this._options;\n    var customTicks = options.customTicks;\n    var customMinorTicks = options.customMinorTicks;\n    return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\n      min: viewPort.minVisible,\n      max: viewPort.maxVisible,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\n      majors: customTicks,\n      minors: customMinorTicks\n    }, options.minorTickInterval, options.minorTickCount, this._initialBreaks);\n  },\n  _createTicksAndLabelFormat: function (range, incidentOccurred) {\n    var options = this._options;\n\n    var ticks = this._getTicks(range, incidentOccurred, false);\n\n    if (!range.isEmpty() && options.type === constants.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\n      options.label.format = formatHelper.getDateFormatByTicks(ticks.ticks);\n    }\n\n    return ticks;\n  },\n\n  getAggregationInfo(useAllAggregatedPoints, range) {\n    var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\n\n    var options = this._options;\n    var marginOptions = this._marginOptions;\n    var businessRange = new Range(this.getTranslator().getBusinessRange()).addRange(range);\n    var visualRange = this.getViewport();\n    var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\n    var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\n    var ticks = [];\n\n    if (options.type === constants.discrete && options.aggregateByCategory) {\n      return {\n        aggregateByCategory: true\n      };\n    }\n\n    var aggregationInterval = options.aggregationInterval;\n    var aggregationGroupWidth = options.aggregationGroupWidth;\n\n    if (!aggregationGroupWidth && marginOptions) {\n      if (marginOptions.checkInterval) {\n        aggregationGroupWidth = options.axisDivisionFactor;\n      }\n\n      if (marginOptions.sizePointNormalState) {\n        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);\n      }\n    }\n\n    var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\n    var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\n    var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\n\n    if (options.type !== constants.discrete) {\n      var min = useAllAggregatedPoints ? businessRange.min : minVisible;\n      var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\n\n      if (isDefined(min) && isDefined(max)) {\n        var add = getAddFunction({\n          base: options.logarithmBase,\n          axisType: options.type,\n          dataType: options.dataType\n        }, false);\n        var start = min;\n        var end = max;\n\n        if (!useAllAggregatedPoints) {\n          var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n          start = add(min, maxMinDistance, -1);\n          end = add(max, maxMinDistance);\n        }\n\n        start = start < businessRange.min ? businessRange.min : start;\n        end = end > businessRange.max ? businessRange.max : end;\n\n        var breaks = this._getScaleBreaks(options, {\n          minVisible: start,\n          maxVisible: end\n        }, this._series, this.isArgumentAxis);\n\n        var filteredBreaks = this._filterBreaks(breaks, {\n          minVisible: start,\n          maxVisible: end\n        }, options.breakStyle);\n\n        ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks;\n      }\n    }\n\n    this._aggregationInterval = tickInterval;\n    return {\n      interval: tickInterval,\n      ticks: ticks\n    };\n  },\n\n  getTickInterval() {\n    return this._tickInterval;\n  },\n\n  getAggregationInterval() {\n    return this._aggregationInterval;\n  },\n\n  createTicks: function (canvas) {\n    var that = this;\n    var renderer = that._renderer;\n    var options = that._options;\n\n    if (!canvas) {\n      return;\n    }\n\n    that._isSynchronized = false;\n    that.updateCanvas(canvas);\n\n    var range = that._getViewportRange();\n\n    that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\n    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _noop, true).tickInterval;\n\n    var margins = this._calculateValueMargins();\n\n    range.addRange({\n      minVisible: margins.minValue,\n      maxVisible: margins.maxValue,\n      isSpacedMargin: margins.isSpacedMargin\n    });\n\n    var ticks = that._createTicksAndLabelFormat(range);\n\n    var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\n\n    if (options.showCustomBoundaryTicks && boundaryTicks.length) {\n      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\n\n      if (boundaryTicks.length > 1) {\n        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));\n      }\n    } else {\n      that._boundaryTicks = [];\n    }\n\n    var minors = (ticks.minorTicks || []).filter(function (minor) {\n      return !boundaryTicks.some(function (boundary) {\n        return valueOf(boundary) === valueOf(minor);\n      });\n    });\n    that._tickInterval = ticks.tickInterval;\n    that._minorTickInterval = ticks.minorTickInterval;\n    var oldMajorTicks = that._majorTicks || [];\n    var majorTicksByValues = oldMajorTicks.reduce((r, t) => {\n      r[t.value.valueOf()] = t;\n      return r;\n    }, {});\n    var sameType = type(ticks.ticks[0]) === type(oldMajorTicks[0] && oldMajorTicks[0].value);\n\n    var skippedCategory = that._getSkippedCategory(ticks.ticks);\n\n    var majorTicks = ticks.ticks.map(v => {\n      var tick = majorTicksByValues[v.valueOf()];\n\n      if (tick && sameType) {\n        delete majorTicksByValues[v.valueOf()];\n        tick.setSkippedCategory(skippedCategory);\n        return tick;\n      } else {\n        return createMajorTick(that, renderer, skippedCategory)(v);\n      }\n    });\n    that._majorTicks = majorTicks;\n    var oldMinorTicks = that._minorTicks || [];\n    that._minorTicks = minors.map((v, i) => {\n      var minorTick = oldMinorTicks[i];\n\n      if (minorTick) {\n        minorTick.updateValue(v);\n        return minorTick;\n      }\n\n      return createMinorTick(that, renderer)(v);\n    });\n    that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\n\n    that._ticksToRemove.forEach(t => {\n      var _t$label;\n\n      return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle();\n    });\n\n    if (ticks.breaks) {\n      that._seriesData.breaks = ticks.breaks;\n    }\n\n    that._reinitTranslator(that._getViewportRange());\n  },\n  _reinitTranslator: function (range) {\n    var translator = this._translator;\n\n    if (this._isSynchronized) {\n      return;\n    }\n\n    translator.updateBusinessRange(range);\n  },\n\n  _getViewportRange() {\n    return this.adjustViewport(this._seriesData);\n  },\n\n  setMarginOptions: function (options) {\n    this._marginOptions = options;\n  },\n\n  getMarginOptions() {\n    var _this$_marginOptions;\n\n    return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {};\n  },\n\n  _calculateRangeInterval: function (interval) {\n    var isDateTime = \"datetime\" === this._options.dataType;\n    var minArgs = [];\n\n    var addToArgs = function (value) {\n      isDefined(value) && minArgs.push(isDateTime ? dateUtils.dateToMilliseconds(value) : value);\n    };\n\n    addToArgs(this._tickInterval);\n    addToArgs(this._estimatedTickInterval);\n    isDefined(interval) && minArgs.push(interval);\n    addToArgs(this._aggregationInterval);\n    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));\n  },\n\n  _calculateWorkWeekInterval(businessInterval) {\n    var options = this._options;\n\n    if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\n      var workWeek = options.workWeek.length * dateIntervals.day;\n      var weekend = dateIntervals.week - workWeek;\n\n      if (workWeek !== businessInterval && weekend < businessInterval) {\n        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\n        businessInterval -= weekend * weekendsCount;\n      } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\n        businessInterval = dateIntervals.day;\n      }\n    }\n\n    return businessInterval;\n  },\n\n  _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\n    var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\n\n    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));\n  },\n\n  _calculateValueMargins(ticks) {\n    this._resetMargins();\n\n    var margins = this.getMarginOptions();\n    var marginSize = (margins.size || 0) / 2;\n    var options = this._options;\n\n    var dataRange = this._getViewportRange();\n\n    var viewPort = this.getViewport();\n\n    var screenDelta = this._getScreenDelta();\n\n    var isDiscrete = -1 !== (options.type || \"\").indexOf(constants.discrete);\n    var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\n    var translator = this._translator;\n    var minValueMargin = options.minValueMargin;\n    var maxValueMargin = options.maxValueMargin;\n    var minPadding = 0;\n    var maxPadding = 0;\n    var interval = 0;\n    var rangeInterval;\n\n    if (dataRange.stubData || !screenDelta) {\n      return {\n        startPadding: 0,\n        endPadding: 0\n      };\n    }\n\n    if (this.isArgumentAxis && margins.checkInterval) {\n      rangeInterval = this._calculateRangeInterval(dataRange.interval);\n      var pxInterval = translator.getInterval(rangeInterval);\n\n      if (isFinite(pxInterval)) {\n        interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)));\n      } else {\n        rangeInterval = 0;\n      }\n    }\n\n    var minPercentPadding;\n    var maxPercentPadding;\n    var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\n\n    if (valueMarginsEnabled) {\n      if (isDefined(minValueMargin)) {\n        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {\n        minPadding = MIN_BAR_MARGIN;\n      } else {\n        minPadding = Math.max(marginSize, interval);\n        minPadding = Math.min(maxPaddingValue, minPadding);\n      }\n\n      if (isDefined(maxValueMargin)) {\n        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {\n        maxPadding = MIN_BAR_MARGIN;\n      } else {\n        maxPadding = Math.max(marginSize, interval);\n        maxPadding = Math.min(maxPaddingValue, maxPadding);\n      }\n    }\n\n    var percentStick = margins.percentStick && !this.isArgumentAxis;\n\n    if (percentStick) {\n      if (1 === _abs(dataRange.max)) {\n        maxPadding = 0;\n      }\n\n      if (1 === _abs(dataRange.min)) {\n        minPadding = 0;\n      }\n    }\n\n    var canvasStartEnd = this._getCanvasStartEnd();\n\n    var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\n    var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\n\n    if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\n      if (void 0 !== minPercentPadding) {\n        minPadding = screenDeltaWithMargins * minPercentPadding;\n      }\n\n      if (void 0 !== maxPercentPadding) {\n        maxPadding = screenDeltaWithMargins * maxPercentPadding;\n      }\n    }\n\n    var minValue;\n    var maxValue;\n\n    if (options.type !== constants.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\n      var length = ticks.length;\n      var firstTickPosition = translator.translate(ticks[0].value);\n      var lastTickPosition = translator.translate(ticks[length - 1].value);\n      var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\n\n      var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\n\n      var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\n\n      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\n        var commonPadding = maxTickPadding + minTickPadding;\n\n        var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\n\n        if (minTickPadding >= minPadding) {\n          minValue = ticks[0].value;\n        }\n\n        if (maxTickPadding >= maxPadding) {\n          maxValue = ticks[length - 1].value;\n        }\n\n        minPadding = _max(minTickPadding, minPadding) / coeff;\n        maxPadding = _max(maxTickPadding, maxPadding) / coeff;\n      }\n    }\n\n    minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\n    maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\n\n    if (!isDiscrete) {\n      if (this._translator.isInverted()) {\n        var _minValue, _maxValue;\n\n        minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);\n      } else {\n        var _minValue2, _maxValue2;\n\n        minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);\n      }\n    }\n\n    var {\n      correctedMin: correctedMin,\n      correctedMax: correctedMax,\n      start: start,\n      end: end\n    } = this.getCorrectedValuesToZero(minValue, maxValue);\n    minPadding = null !== start && void 0 !== start ? start : minPadding;\n    maxPadding = null !== end && void 0 !== end ? end : maxPadding;\n    return {\n      startPadding: translator.isInverted() ? maxPadding : minPadding,\n      endPadding: translator.isInverted() ? minPadding : maxPadding,\n      minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\n      maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\n      interval: rangeInterval,\n      isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\n    };\n  },\n\n  getCorrectedValuesToZero(minValue, maxValue) {\n    var that = this;\n    var translator = that._translator;\n\n    var canvasStartEnd = that._getCanvasStartEnd();\n\n    var dataRange = that._getViewportRange();\n\n    var screenDelta = that._getScreenDelta();\n\n    var options = that._options;\n    var start;\n    var end;\n    var correctedMin;\n    var correctedMax;\n\n    var correctZeroLevel = (minPoint, maxPoint) => {\n      var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\n\n      var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\n\n      var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\n\n      start = minExpectedPadding / coeff;\n      end = maxExpectedPadding / coeff;\n    };\n\n    if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\n      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\n        correctZeroLevel(translator.translate(0), translator.translate(maxValue));\n        correctedMin = 0;\n      }\n\n      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\n        correctZeroLevel(translator.translate(minValue), translator.translate(0));\n        correctedMax = 0;\n      }\n    }\n\n    return {\n      start: isFinite(start) ? start : null,\n      end: isFinite(end) ? end : null,\n      correctedMin: correctedMin,\n      correctedMax: correctedMax\n    };\n  },\n\n  applyMargins() {\n    if (this._isSynchronized) {\n      return;\n    }\n\n    var margins = this._calculateValueMargins(this._majorTicks);\n\n    var canvas = extend({}, this._canvas, {\n      startPadding: margins.startPadding,\n      endPadding: margins.endPadding\n    });\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    if (isFinite(margins.interval)) {\n      var br = this._translator.getBusinessRange();\n\n      br.addRange({\n        interval: margins.interval\n      });\n\n      this._translator.updateBusinessRange(br);\n    }\n  },\n\n  _resetMargins: function () {\n    this._reinitTranslator(this._getViewportRange());\n\n    if (this._canvas) {\n      this._translator.updateCanvas(this._processCanvas(this._canvas));\n    }\n  },\n\n  _createConstantLines() {\n    var constantLines = (this._options.constantLines || []).map(o => createConstantLine(this, o));\n    this._outsideConstantLines = constantLines.filter(l => \"outside\" === l.labelPosition);\n    this._insideConstantLines = constantLines.filter(l => \"inside\" === l.labelPosition);\n  },\n\n  draw: function (canvas, borderOptions) {\n    var that = this;\n    var options = this._options;\n    that.borderOptions = borderOptions || {\n      visible: false\n    };\n\n    that._resetMargins();\n\n    that.createTicks(canvas);\n    that.applyMargins();\n\n    that._clearAxisGroups();\n\n    initTickCoords(that._majorTicks);\n    initTickCoords(that._minorTicks);\n    initTickCoords(that._boundaryTicks);\n\n    that._axisGroup.append(that._axesContainerGroup);\n\n    that._drawAxis();\n\n    that._drawTitle();\n\n    drawTickMarks(that._majorTicks, options.tick);\n    drawTickMarks(that._minorTicks, options.minorTick);\n    drawTickMarks(that._boundaryTicks, options.tick);\n\n    var drawGridLine = that._getGridLineDrawer();\n\n    drawGrids(that._majorTicks, drawGridLine);\n    drawGrids(that._minorTicks, drawGridLine);\n    callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\n    that._templatesRendered && that._templatesRendered.reject();\n    that._templatesRendered = new Deferred();\n\n    that._majorTicks.forEach(function (tick) {\n      tick.labelRotationAngle = 0;\n      tick.labelAlignment = void 0;\n      tick.labelOffset = 0;\n    });\n\n    callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\n    callAction(that._strips, \"draw\");\n    that._dateMarkers = that._drawDateMarkers() || [];\n    that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\n    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\n    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\n    that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\n\n    if (that._constantLinesGroup) {\n      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);\n    }\n\n    that._measureTitle();\n\n    measureLabels(that._majorTicks);\n    !options.label.template && that._applyWordWrap();\n    measureLabels(that._outsideConstantLines);\n    measureLabels(that._insideConstantLines);\n    measureLabels(that._strips);\n    measureLabels(that._dateMarkers);\n\n    that._adjustConstantLineLabels(that._insideConstantLines);\n\n    that._adjustStripLabels();\n\n    var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\n\n    if (!that._translator.getBusinessRange().isEmpty()) {\n      that._setLabelsPlacement();\n\n      offset = that._adjustLabels(offset);\n    }\n\n    when.apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {\n      that._templatesRendered.resolve();\n    });\n    offset = that._adjustDateMarkers(offset);\n\n    that._adjustTitle(offset);\n  },\n\n  getTemplatesDef() {\n    return this._templatesRendered;\n  },\n\n  setRenderedState(state) {\n    this._drawn = state;\n  },\n\n  isRendered() {\n    return this._drawn;\n  },\n\n  _applyWordWrap() {\n    var convertedTickInterval;\n    var textWidth;\n    var textHeight;\n    var options = this._options;\n    var tickInterval = this._tickInterval;\n\n    if (isDefined(tickInterval)) {\n      convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n    }\n\n    var displayMode = this._validateDisplayMode(options.label.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\n\n    var wordWrapMode = options.label.wordWrap || \"none\";\n    var overflowMode = options.label.textOverflow || \"none\";\n\n    if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\n      var usefulSpace = isDefined(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\n\n      if (this._isHorizontal) {\n        textWidth = convertedTickInterval;\n        textHeight = usefulSpace;\n      } else {\n        textWidth = usefulSpace;\n        textHeight = convertedTickInterval;\n      }\n\n      var correctByWidth = false;\n      var correctByHeight = false;\n\n      if (textWidth) {\n        if (this._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {\n          correctByWidth = true;\n        }\n      }\n\n      if (textHeight) {\n        if (this._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {\n          correctByHeight = true;\n        }\n      }\n\n      if (correctByWidth || correctByHeight) {\n        this._majorTicks.forEach(tick => {\n          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);\n        });\n\n        measureLabels(this._majorTicks);\n      }\n    }\n  },\n\n  _measureTitle: _noop,\n\n  animate() {\n    callAction(this._majorTicks, \"animateLabels\");\n  },\n\n  updateSize(canvas, animate) {\n    var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\n    this.updateCanvas(canvas);\n\n    if (updateTitle) {\n      this._checkTitleOverflow();\n\n      this._measureTitle();\n\n      this._updateTitleCoords();\n    }\n\n    this._reinitTranslator(this._getViewportRange());\n\n    this.applyMargins();\n    var animationEnabled = !this._firstDrawing && animate;\n    var options = this._options;\n    initTickCoords(this._majorTicks);\n    initTickCoords(this._minorTicks);\n    initTickCoords(this._boundaryTicks);\n\n    if (this._resetApplyingAnimation && !this._firstDrawing) {\n      this._resetStartCoordinates();\n    }\n\n    cleanUpInvalidTicks(this._majorTicks);\n    cleanUpInvalidTicks(this._minorTicks);\n    cleanUpInvalidTicks(this._boundaryTicks);\n\n    if (this._axisElement) {\n      this._updateAxisElementPosition();\n    }\n\n    updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\n    updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\n    updateTicksPosition(this._boundaryTicks, options.tick);\n    callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\n\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));\n\n    callAction(this._strips, \"updatePosition\", animationEnabled);\n    updateGridsPosition(this._majorTicks, animationEnabled);\n    updateGridsPosition(this._minorTicks, animationEnabled);\n\n    if (animationEnabled) {\n      callAction(this._ticksToRemove || [], \"fadeOutElements\");\n    }\n\n    this.prepareAnimation();\n    this._ticksToRemove = null;\n\n    if (!this._translator.getBusinessRange().isEmpty()) {\n      this._firstDrawing = false;\n    }\n\n    this._resetApplyingAnimation = false;\n\n    this._updateLabelsPosition();\n  },\n\n  _updateLabelsPosition: _noop,\n\n  prepareAnimation() {\n    var action = \"saveCoords\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n\n  _resetStartCoordinates() {\n    var action = \"resetCoordinates\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n\n  applyClipRects: function (elementsClipID, canvasClipID) {\n    this._axisGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n\n    this._axisStripGroup.attr({\n      \"clip-path\": elementsClipID\n    });\n\n    this._axisElementsGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n  },\n\n  _validateVisualRange(optionValue) {\n    var range = getVizRangeObject(optionValue);\n\n    if (void 0 !== range.startValue) {\n      range.startValue = this.validateUnit(range.startValue);\n    }\n\n    if (void 0 !== range.endValue) {\n      range.endValue = this.validateUnit(range.endValue);\n    }\n\n    return convertVisualRangeObject(range, !_isArray(optionValue));\n  },\n\n  _validateOptions(options) {\n    options.wholeRange = this._validateVisualRange(options.wholeRange);\n    options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\n\n    this._setVisualRange(options._customVisualRange);\n  },\n\n  validate() {\n    var options = this._options;\n    var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\n    var parser = dataType ? getParser(dataType) : function (unit) {\n      return unit;\n    };\n    this.parser = parser;\n    options.dataType = dataType;\n\n    this._validateOptions(options);\n  },\n\n  resetVisualRange(isSilent) {\n    this._seriesData.minVisible = this._seriesData.min;\n    this._seriesData.maxVisible = this._seriesData.max;\n    this.handleZooming([null, null], {\n      start: !!isSilent,\n      end: !!isSilent\n    });\n  },\n\n  _setVisualRange(visualRange, allowPartialUpdate) {\n    var range = this.adjustRange(getVizRangeObject(visualRange));\n\n    if (allowPartialUpdate) {\n      isDefined(range.startValue) && (this._viewport.startValue = range.startValue);\n      isDefined(range.endValue) && (this._viewport.endValue = range.endValue);\n    } else {\n      this._viewport = range;\n    }\n  },\n\n  _applyZooming(visualRange, allowPartialUpdate) {\n    this._resetVisualRangeOption();\n\n    this._setVisualRange(visualRange, allowPartialUpdate);\n\n    var viewPort = this.getViewport();\n    this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\n      minVisible: viewPort.startValue,\n      maxVisible: viewPort.endValue\n    }, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n\n  getZoomStartEventArg(event, actionType) {\n    return {\n      axis: this,\n      range: this.visualRange(),\n      cancel: false,\n      event: event,\n      actionType: actionType\n    };\n  },\n\n  _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\n    var newRange = this.visualRange();\n    return {\n      axis: this,\n      previousRange: previousRange,\n      range: newRange,\n      cancel: false,\n      event: event,\n      actionType: actionType,\n      zoomFactor: zoomFactor,\n      shift: shift,\n      rangeStart: newRange.startValue,\n      rangeEnd: newRange.endValue\n    };\n  },\n\n  getZoomBounds() {\n    var wholeRange = getVizRangeObject(this._options.wholeRange);\n    var range = this.getTranslator().getBusinessRange();\n    var secondPriorityRange = {\n      startValue: getZoomBoundValue(this._initRange.startValue, range.min),\n      endValue: getZoomBoundValue(this._initRange.endValue, range.max)\n    };\n    return {\n      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\n      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\n    };\n  },\n\n  setInitRange() {\n    this._initRange = {};\n\n    if (0 === Object.keys(this._options.wholeRange || {}).length) {\n      this._initRange = this.getZoomBounds();\n    }\n  },\n\n  _resetVisualRangeOption() {\n    this._options._customVisualRange = {};\n  },\n\n  getTemplatesGroups() {\n    var ticks = this._majorTicks;\n\n    if (ticks) {\n      return this._majorTicks.map(tick => tick.templateContainer).filter(item => isDefined(item));\n    } else {\n      return [];\n    }\n  },\n\n  setCustomVisualRange(range) {\n    this._options._customVisualRange = range;\n  },\n\n  visualRange() {\n    var args = arguments;\n    var visualRange;\n\n    if (0 === args.length) {\n      var adjustedRange = this._getAdjustedBusinessRange();\n\n      var startValue = adjustedRange.minVisible;\n      var endValue = adjustedRange.maxVisible;\n\n      if (this._options.type === constants.discrete) {\n        var _startValue, _endValue;\n\n        startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\n        endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\n        return {\n          startValue: startValue,\n          endValue: endValue,\n          categories: getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\n        };\n      }\n\n      return {\n        startValue: startValue,\n        endValue: endValue\n      };\n    } else if (_isArray(args[0])) {\n      visualRange = args[0];\n    } else if (isPlainObject(args[0])) {\n      visualRange = extend({}, args[0]);\n    } else {\n      visualRange = [args[0], args[1]];\n    }\n\n    var zoomResults = this.handleZooming(visualRange, args[1]);\n\n    if (!zoomResults.isPrevented) {\n      this._visualRange(this, zoomResults);\n    }\n  },\n\n  handleZooming(visualRange, preventEvents, domEvent, action) {\n    preventEvents = preventEvents || {};\n\n    if (isDefined(visualRange)) {\n      visualRange = this._validateVisualRange(visualRange);\n      visualRange.action = action;\n    }\n\n    var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\n    var previousRange = zoomStartEvent.range;\n    !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\n    var zoomResults = {\n      isPrevented: zoomStartEvent.cancel,\n      skipEventRising: preventEvents.skipEventRising,\n      range: visualRange || zoomStartEvent.range\n    };\n\n    if (!zoomStartEvent.cancel) {\n      isDefined(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\n\n      if (!isDefined(this._storedZoomEndParams)) {\n        this._storedZoomEndParams = {\n          startRange: previousRange,\n          type: this.getOptions().type\n        };\n      }\n\n      this._storedZoomEndParams.event = domEvent;\n      this._storedZoomEndParams.action = action;\n      this._storedZoomEndParams.prevent = !!preventEvents.end;\n    }\n\n    return zoomResults;\n  },\n\n  handleZoomEnd() {\n    if (isDefined(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\n      var previousRange = this._storedZoomEndParams.startRange;\n      var domEvent = this._storedZoomEndParams.event;\n      var action = this._storedZoomEndParams.action;\n      var previousBusinessRange = {\n        minVisible: previousRange.startValue,\n        maxVisible: previousRange.endValue,\n        categories: previousRange.categories\n      };\n\n      var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\n\n      var shift = typeIsNotChanged ? adjust(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\n      var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\n\n      var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\n\n      zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\n\n      this._eventTrigger(\"zoomEnd\", zoomEndEvent);\n\n      if (zoomEndEvent.cancel) {\n        this._restorePreviousVisualRange(previousRange);\n      }\n\n      this._storedZoomEndParams = null;\n    }\n  },\n\n  _restorePreviousVisualRange(previousRange) {\n    this._storedZoomEndParams = null;\n\n    this._applyZooming(previousRange);\n\n    this._visualRange(this, previousRange);\n  },\n\n  checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\n    var options = this._options;\n    var translator = this._translator;\n    var minZoom = options.minVisualRangeLength;\n    var correctedRange = range;\n    var visualRange;\n    var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\n    var businessRange = translator.getBusinessRange();\n\n    if (range) {\n      visualRange = this.adjustRange(getVizRangeObject(range));\n      visualRange = {\n        minVisible: visualRange.startValue,\n        maxVisible: visualRange.endValue,\n        categories: businessRange.categories\n      };\n    }\n\n    var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\n    var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\n\n    if (isDefined(minZoom) || \"discrete\" === options.type) {\n      minZoom = translator.convert(minZoom);\n\n      if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\n        correctedRange = getVizRangeObject(translator.getRangeByMinZoomValue(minZoom, visualRange));\n        isOvercoming = false;\n      } else {\n        isOvercoming &= minZoom > afterVisualRangeLength;\n      }\n    } else {\n      var canvasLength = this._translator.canvasLength;\n      var fullRange = {\n        minVisible: businessRange.min,\n        maxVisible: businessRange.max,\n        categories: businessRange.categories\n      };\n      isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength;\n    }\n\n    return {\n      stopInteraction: !!isOvercoming,\n      correctedRange: correctedRange\n    };\n  },\n\n  isExtremePosition(isMax) {\n    var extremeDataValue;\n    var seriesData;\n\n    if (\"discrete\" === this._options.type) {\n      seriesData = this._translator.getBusinessRange();\n      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];\n    } else {\n      seriesData = this.getZoomBounds();\n      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;\n    }\n\n    var translator = this.getTranslator();\n    var extremePoint = translator.translate(extremeDataValue);\n    var visualRange = this.visualRange();\n    var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\n    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;\n  },\n\n  getViewport() {\n    return this._viewport;\n  },\n\n  getFullTicks: function () {\n    var majors = this._majorTicks || [];\n\n    if (this._options.type === constants.discrete) {\n      return convertTicksToValues(majors);\n    } else {\n      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {\n        return valueOf(a) - valueOf(b);\n      });\n    }\n  },\n  measureLabels: function (canvas, withIndents) {\n    var that = this;\n    var options = that._options;\n    var widthAxis = options.visible ? options.width : 0;\n    var ticks;\n    var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\n    var tickInterval;\n\n    var viewportRange = that._getViewportRange();\n\n    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\n      return {\n        height: widthAxis,\n        width: widthAxis,\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (that._majorTicks) {\n      ticks = convertTicksToValues(that._majorTicks);\n    } else {\n      that.updateCanvas(canvas);\n      ticks = that._createTicksAndLabelFormat(viewportRange, _noop);\n      tickInterval = ticks.tickInterval;\n      ticks = ticks.ticks;\n    }\n\n    var maxText = ticks.reduce(function (prevLabel, tick, index) {\n      var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\n\n      if (prevLabel.length < label.length) {\n        return label;\n      } else {\n        return prevLabel;\n      }\n    }, that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\n\n    var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\n\n    var box = text.getBBox();\n    text.remove();\n    return {\n      x: box.x,\n      y: box.y,\n      width: box.width + indent,\n      height: box.height + indent\n    };\n  },\n  _setLabelsPlacement: function () {\n    if (!this._options.label.visible) {\n      return;\n    }\n\n    var labelOpt = this._options.label;\n\n    var displayMode = this._validateDisplayMode(labelOpt.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\n\n    var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\n    var behavior = {\n      rotationAngle: labelOpt.rotationAngle,\n      staggeringSpacing: labelOpt.staggeringSpacing\n    };\n    var notRecastStep;\n\n    var boxes = this._majorTicks.map(function (tick) {\n      return tick.labelBBox;\n    });\n\n    var step = this._getStep(boxes);\n\n    switch (displayMode) {\n      case ROTATE:\n        if (ignoreOverlapping) {\n          notRecastStep = true;\n          step = 1;\n        }\n\n        this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\n\n        break;\n\n      case \"stagger\":\n        if (ignoreOverlapping) {\n          step = 2;\n        }\n\n        this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\n\n        break;\n\n      default:\n        this._applyLabelOverlapping(boxes, overlappingMode, step, behavior);\n\n    }\n  },\n  _applyLabelOverlapping: function (boxes, mode, step, behavior) {\n    var labelOpt = this._options.label;\n    var majorTicks = this._majorTicks;\n\n    if (\"none\" === mode || \"ignore\" === mode) {\n      return;\n    }\n\n    if (step > 1 && boxes.some(function (box, index, array) {\n      if (0 === index) {\n        return false;\n      }\n\n      return constants.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);\n    })) {\n      this._applyLabelMode(mode, step, boxes, behavior);\n    }\n\n    this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\n\n    this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment);\n  },\n  _applyLabelMode: function (mode, step, boxes, behavior, notRecastStep) {\n    var majorTicks = this._majorTicks;\n    var labelOpt = this._options.label;\n    var angle = behavior.rotationAngle;\n    var labelHeight;\n    var alignment;\n    var func;\n\n    switch (mode) {\n      case ROTATE:\n        if (!labelOpt.userAlignment) {\n          alignment = angle < 0 ? RIGHT : LEFT;\n\n          if (angle % 90 === 0) {\n            alignment = CENTER;\n          }\n        }\n\n        step = notRecastStep ? step : this._getStep(boxes, angle);\n\n        func = function (tick) {\n          var contentContainer = tick.getContentContainer();\n\n          if (!contentContainer) {\n            return;\n          }\n\n          contentContainer.rotate(angle);\n          tick.labelRotationAngle = angle;\n          alignment && (tick.labelAlignment = alignment);\n        };\n\n        updateLabels(majorTicks, step, func);\n        break;\n\n      case \"stagger\":\n        labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\n\n        func = function (tick, index) {\n          if (index / (step - 1) % 2 !== 0) {\n            tick.labelOffset = labelHeight;\n          }\n        };\n\n        updateLabels(majorTicks, step - 1, func);\n        break;\n\n      case \"auto\":\n      case \"_auto\":\n        if (2 === step) {\n          this._applyLabelMode(\"stagger\", step, boxes, behavior);\n        } else {\n          this._applyLabelMode(ROTATE, step, boxes, {\n            rotationAngle: getOptimalAngle(boxes, labelOpt)\n          });\n        }\n\n        break;\n\n      default:\n        updateLabels(majorTicks, step);\n    }\n  },\n  getMarkerTrackers: _noop,\n  _drawDateMarkers: _noop,\n  _adjustDateMarkers: _noop,\n  coordsIn: _noop,\n  areCoordsOutsideAxis: _noop,\n  _getSkippedCategory: _noop,\n  _initAxisPositions: _noop,\n  _drawTitle: _noop,\n  _updateTitleCoords: _noop,\n  _adjustConstantLineLabels: _noop,\n  _createTranslator: function () {\n    return new Translator2D({}, {}, {});\n  },\n  _updateTranslator: function () {\n    var translator = this._translator;\n    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());\n  },\n  _getTranslatorOptions: function () {\n    var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\n\n    var options = this._options;\n    return {\n      isHorizontal: this._isHorizontal,\n      shiftZeroValue: !this.isArgumentAxis,\n      interval: options.semiDiscreteInterval,\n      firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\n      stick: this._getStick(),\n      breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\n    };\n  },\n\n  getVisibleArea() {\n    var canvas = this._getCanvasStartEnd();\n\n    return [canvas.start, canvas.end].sort((a, b) => a - b);\n  },\n\n  _getCanvasStartEnd: function () {\n    var isHorizontal = this._isHorizontal;\n    var canvas = this._canvas || {};\n\n    var invert = this._translator.getBusinessRange().invert;\n\n    var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\n    invert && coords.reverse();\n    return {\n      start: coords[0],\n      end: coords[1]\n    };\n  },\n  _getScreenDelta: function () {\n    var canvas = this._getCanvasStartEnd();\n\n    var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\n    var breaksLength = breaks.length;\n\n    var screenDelta = _abs(canvas.start - canvas.end);\n\n    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);\n  },\n  _getScaleBreaks: function () {\n    return [];\n  },\n  _filterBreaks: function () {\n    return [];\n  },\n  _adjustTitle: _noop,\n  _checkTitleOverflow: _noop,\n  getSpiderTicks: _noop,\n  setSpiderTicks: _noop,\n  _checkBoundedLabelsOverlapping: _noop,\n  _checkShiftedLabels: _noop,\n  drawScaleBreaks: _noop,\n  _visualRange: _noop,\n  _rotateConstantLine: _noop,\n\n  applyVisualRangeSetter(visualRangeSetter) {\n    this._visualRange = visualRangeSetter;\n  },\n\n  getCategoriesSorter(argCategories) {\n    var sort;\n\n    if (this.isArgumentAxis) {\n      sort = argCategories;\n    } else {\n      var categoriesSortingMethod = this._options.categoriesSortingMethod;\n      sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories;\n    }\n\n    return sort;\n  },\n\n  _getAdjustedBusinessRange() {\n    return this.adjustViewport(this._translator.getBusinessRange());\n  }\n\n};","map":{"version":3,"sources":["/Users/krunalpatel/Downloads/React-Firebase-Auth-master 3/node_modules/devextreme/esm/viz/axes/base_axis.js"],"names":["smartFormatter","_format","formatRange","patchFontOptions","getVizRangeObject","getLogExt","getLog","raiseToExt","raiseTo","valueOf","rotateBBox","getCategoriesInfo","adjustVisualRange","getAddFunction","convertVisualRangeObject","isDefined","isFunction","isPlainObject","type","constants","extend","formatHelper","getParser","tickGenerator","Translator2D","Range","tick","adjust","dateUtils","noop","_noop","xyMethods","polarMethods","createConstantLine","createStrip","Deferred","when","calculateCanvasMargins","measureLabels","convertTicksToValues","_math","Math","_abs","abs","_max","max","_min","min","_isArray","Array","isArray","DEFAULT_AXIS_LABEL_SPACING","MAX_GRID_BORDER_ADHENSION","TOP","top","BOTTOM","bottom","LEFT","left","RIGHT","right","CENTER","center","KEEP","SHIFT","RESET","ROTATE","DEFAULT_AXIS_DIVISION_FACTOR","DEFAULT_MINOR_AXIS_DIVISION_FACTOR","SCROLL_THRESHOLD","MIN_BAR_MARGIN","MAX_MARGIN_VALUE","dateIntervals","day","week","getTickGenerator","options","incidentOccurred","skipTickGeneration","rangeIsEmpty","adjustDivisionFactor","_ref","_options$workWeek","allowNegatives","linearThreshold","axisType","dataType","logBase","logarithmBase","axisDivisionFactor","minorAxisDivisionFactor","numberMultipliers","calculateMinors","minorTick","visible","minorGrid","allowDecimals","endOnTick","firstDayOfWeek","workWeek","skipCalculationLimits","generateExtraTick","minTickInterval","createMajorTick","axis","renderer","skippedCategory","getOptions","grid","createMinorTick","createBoundaryTick","isFirst","showCustomBoundaryTicks","callAction","elements","action","actionArgument1","actionArgument2","forEach","e","initTickCoords","ticks","drawTickMarks","drawGrids","drawLine","updateTicksPosition","animate","updateGridsPosition","cleanUpInvalidTicks","i","length","removeInvalidTick","coords","x","y","splice","validateAxisOptions","_labelOptions$minSpac","labelOptions","label","position","defaultPosition","isHorizontal","secondaryPosition","labelPosition","alignment","userAlignment","hoverMode","toLowerCase","minSpacing","argumentType","valueType","getOptimalAngle","boxes","labelOpt","angle","asin","height","PI","updateLabels","step","func","index","getContentContainer","removeLabel","getZoomBoundValue","optionValue","dataValue","configureGenerator","viewPort","screenDelta","tickGeneratorOptions","tickInterval","breaks","isEmpty","v","categories","isSpacedMargin","getConstantLineSharpDirection","coord","axisCanvas","start","end","Axis","renderSettings","_renderer","_incidentOccurred","_eventTrigger","eventTrigger","_stripsGroup","stripsGroup","_stripLabelAxesGroup","stripLabelAxesGroup","_labelsAxesGroup","labelsAxesGroup","_constantLinesGroup","constantLinesGroup","_scaleBreaksGroup","scaleBreaksGroup","_axesContainerGroup","axesContainerGroup","_gridContainerGroup","gridGroup","_axisCssPrefix","widgetClass","axisClass","_setType","drawingType","_createAxisGroups","_translator","_createTranslator","isArgumentAxis","_viewport","_prevDataInfo","_firstDrawing","_initRange","_getTemplate","getTemplate","prototype","constructor","_drawAxis","_options","_axisElement","_createAxisElement","_updateAxisElementPosition","attr","width","stroke","color","opacity","sharp","_getSharpParam","getAxisSharpDirection","append","_axisLineGroup","_createPathElement","points","sharpDirection","path","svgElement","arguments","customPositionIsAvailable","getOrthogonalAxis","getCustomPosition","getCustomBoundaryPosition","resolveOverlappingForCustomPositioning","hasNonBoundaryPosition","customPositionIsBoundaryOrthogonalAxis","getResolvedBoundaryPosition","getSharpDirectionByCoords","canvas","_getCanvasStartEnd","maxCoord","getRadius","_isHorizontal","_getGridLineDrawer","that","gridStyle","_getGridPoints","tickPositionField","orthogonalPositions","_orthogonalPositions","positionFrom","positionTo","borderOptions","canvasStart","canvasEnd","getCanvas","firstBorderLinePosition","lastBorderLinePosition","minDelta","maxDelta","areCoordsOutsideAxis","_getConstantLinePos","parsedValue","value","_getTranslatedCoord","_getConstantLineGraphicAttributes","_createConstantLine","_drawConstantLineLabelText","text","_ref2","group","font","cssClass","css","align","class","_drawConstantLineLabels","lineLabelOptions","_text","_checkAlignmentConstantLineLabels","formatLabel","_getConstantLineLabelsCoords","_getStripPos","startValue","endValue","range","isContinuous","minVisible","maxVisible","reduce","result","cat","push","swap","startCategoryIndex","endCategoryIndex","_parsedStartValue$val","_parsedEndValue$value","parsedStartValue","parser","parsedEndValue","indexOf","from","to","outOfCanvas","validateUnit","stripPosition","visibleArea","getVisibleArea","_getStripGraphicAttributes","fromPoint","toPoint","_createStrip","attrs","rect","_adjustStripLabels","_strips","strip","_getAdjustedStripLabelCoords","_adjustLabelsCoord","offset","maxWidth","checkCanvas","getContainerAttrs","_getLabelAdjustedCoord","labelOffset","_majorTicks","updateMultilineTextAlignment","templateContainer","_adjustLabels","positionsAreConsistent","maxSize","size","bBox","labelRotationAngle","labelBBox","labelCoords","additionalOffset","indentFromAxis","templateBox","getBBox","box","textAlign","labelAlignment","isDiscrete","isFlatLabel","axisPosition","_axisPosition","labelX","translateX","translateY","_createAxisConstantLineGroups","classSelector","constantLinesClass","insideGroup","g","outsideGroup1","outsideGroup2","inside","outside1","outside2","remove","clear","_axisGroup","enableLinks","_axisStripGroup","_axisGridGroup","_axisElementsGroup","linkOn","linkAppend","_axisTitleGroup","_axisConstantLineGroups","above","under","_axisStripLabelGroup","_clearAxisGroups","template","isRendered","_getLabelFormatObject","point","_getViewportRange","formatObject","valueText","_tickInterval","showTransition","marker","customizeText","call","formatHint","customizeHint","interval","argumentFormat","axisOptions","_setTickOffset","discreteAxisDivisionMode","_tickOffset","aggregatedPointBetweenTicks","aggregatedPointsPosition","resetApplyingAnimation","isFirstDrawing","_resetApplyingAnimation","getMargins","customPosition","placeholderSize","crosshairMargin","isDefinedCustomPositionOption","boundaryPosition","cLeft","cTop","cRight","cBottom","edgeMarginCorrection","constantLineAboveSeries","constantLineUnderSeries","map","concat","margins","moveByOffset","customPositionIsBoundary","unit","idError","parameters","axisTypeMethods","_disposeBreaksGroup","dispose","_title","_axisBreaksGroup","_textOptions","_textFontStyles","_minorTicks","_templatesRendered","reject","setPane","pane","setTypes","typeSelector","_updateTranslator","resetTypes","_initTypes","getTranslator","updateOptions","title","name","priority","_hasLabelFormat","format","logarithmic","logarithmBaseError","_createConstantLines","strips","o","calculateInterval","prevValue","getBusinessRange","getCanvasRange","translator","translate","_processCanvas","updateCanvas","canvasRedesign","positions","_canvas","_initAxisPositions","getAxisShift","_axisShift","hideTitle","getTitle","hideOuterElements","_outsideConstantLines","_resolveLogarithmicOptionsForRange","addRange","isNaN","adjustViewport","businessRange","discrete","_seriesData","wholeRange","adjustRange","visualRange","getViewport","_addConstantLinesToRange","minDefined","maxDefined","_wholeRange$startValu","_wholeRange$endValue","categoriesInfo","adjustedVisualRange","base","isLogarithmic","disabledNegatives","tmp","_getVisualRangeUpdateMode","viewport","newRange","oppositeValue","visualRangeUpdateMode","prevDataInfo","containsConstantLine","newCategories","c","join","minPoint","minVisiblePoint","maxPoint","maxVisiblePoint","_handleBusinessRangeChanged","oppositeVisualRangeUpdateMode","axisReinitialized","_lastVisualRangeUpdateMode","_setVisualRange","getVisualRangeLength","currentBusinessRange","getVisualRangeCenter","useMerge","ceil","toValue","setBusinessRange","argCategories","_that$_seriesData$min","_that$_seriesData$max","dataIsEmpty","rangeWithConstantLines","invert","inverted","synchronizedValue","showZero","correctValueZeroLevel","sortCategories","getCategoriesSorter","userBreaks","_getScaleBreaks","_series","updateBusinessRange","dataRange","minValueField","maxValueField","_insideConstantLines","cl","extendAxis","getParsedValue","setGroupSeries","series","getLabelsPosition","labelShift","_constantLabelOffset","getFormattedValue","_getBoundaryTicks","majors","customBounds","customBoundTicks","addMinMax","_boundaryTicksVisibility","boundaryTicks","setPercentLabelFormat","resetAutoLabelFormat","getMultipleAxesSpacing","multipleAxesSpacing","getTicksValues","majorTicksValues","minorTicksValues","estimateTickInterval","_getTicks","setTicks","majorTicks","_getSkippedCategory","minorTicks","_isSynchronized","_adjustDivisionFactor","val","customTicks","customMinorTicks","bind","_getScreenDelta","overlappingBehavior","forceUserTickInterval","minors","minorTickInterval","minorTickCount","_initialBreaks","_createTicksAndLabelFormat","getDateFormatByTicks","getAggregationInfo","useAllAggregatedPoints","_visualRange$startVal","_visualRange$endValue","_that$_seriesData","marginOptions","_marginOptions","aggregateByCategory","aggregationInterval","aggregationGroupWidth","checkInterval","sizePointNormalState","minInterval","generateTicks","add","maxMinDistance","dateToMilliseconds","filteredBreaks","_filterBreaks","breakStyle","_aggregationInterval","getTickInterval","getAggregationInterval","createTicks","_estimatedTickInterval","_calculateValueMargins","minValue","maxValue","_boundaryTicks","filter","minor","some","boundary","_minorTickInterval","oldMajorTicks","majorTicksByValues","r","t","sameType","setSkippedCategory","oldMinorTicks","updateValue","_ticksToRemove","Object","keys","k","slice","_t$label","removeTitle","_reinitTranslator","setMarginOptions","getMarginOptions","_this$_marginOptions","_calculateRangeInterval","isDateTime","minArgs","addToArgs","_calculateWorkWeekInterval","apply","businessInterval","workdaysOnly","weekend","weekendsCount","_getConvertIntervalCoefficient","intervalInPx","ratioOfCanvasRange","_resetMargins","marginSize","valueMarginsEnabled","minValueMargin","maxValueMargin","minPadding","maxPadding","rangeInterval","stubData","startPadding","endPadding","pxInterval","getInterval","isFinite","minPercentPadding","maxPercentPadding","maxPaddingValue","percentStick","canvasStartEnd","commonMargin","screenDeltaWithMargins","skipViewportExtending","firstTickPosition","lastTickPosition","invertMultiplier","minTickPadding","maxTickPadding","commonPadding","coeff","isInverted","_minValue","_maxValue","_minValue2","_maxValue2","correctedMin","correctedMax","getCorrectedValuesToZero","correctZeroLevel","minExpectedPadding","maxExpectedPadding","applyMargins","br","constantLines","l","draw","_drawTitle","drawGridLine","_dateMarkers","_drawDateMarkers","_measureTitle","_applyWordWrap","_adjustConstantLineLabels","_setLabelsPlacement","getTemplateDeferred","done","resolve","_adjustDateMarkers","_adjustTitle","getTemplatesDef","setRenderedState","state","_drawn","convertedTickInterval","textWidth","textHeight","displayMode","_validateDisplayMode","overlappingMode","_validateOverlappingMode","wordWrapMode","wordWrap","overflowMode","textOverflow","usefulSpace","correctByWidth","correctByHeight","setMaxSize","updateSize","updateTitle","_checkTitleOverflow","_updateTitleCoords","animationEnabled","_resetStartCoordinates","updatePosition","prepareAnimation","_updateLabelsPosition","applyClipRects","elementsClipID","canvasClipID","_validateVisualRange","_validateOptions","_customVisualRange","validate","resetVisualRange","isSilent","handleZooming","allowPartialUpdate","_applyZooming","_resetVisualRangeOption","getZoomStartEventArg","event","actionType","cancel","_getZoomEndEventArg","previousRange","zoomFactor","shift","rangeStart","rangeEnd","getZoomBounds","secondPriorityRange","setInitRange","getTemplatesGroups","item","setCustomVisualRange","args","adjustedRange","_getAdjustedBusinessRange","_startValue","_endValue","zoomResults","isPrevented","_visualRange","preventEvents","domEvent","zoomStartEvent","skipEventRising","_storedZoomEndParams","startRange","prevent","handleZoomEnd","previousBusinessRange","typeIsNotChanged","NaN","round","zoomEndEvent","checkZoomingLowerLimitOvercome","stopInteraction","_restorePreviousVisualRange","minZoom","minVisualRangeLength","correctedRange","isOvercoming","beforeVisualRangeLength","afterVisualRangeLength","convert","getRangeByMinZoomValue","canvasLength","fullRange","isExtremePosition","isMax","extremeDataValue","seriesData","extremePoint","visualRangePoint","getFullTicks","sort","a","b","withIndents","widthAxis","indent","viewportRange","maxText","prevLabel","root","ignoreOverlapping","behavior","rotationAngle","staggeringSpacing","notRecastStep","_getStep","_applyLabelMode","_applyLabelOverlapping","mode","array","areLabelsOverlap","_checkBoundedLabelsOverlapping","_checkShiftedLabels","labelHeight","contentContainer","rotate","_getMaxLabelHeight","getMarkerTrackers","coordsIn","update","_getTranslatorOptions","_options$workWeek2","_options$breakStyle$w","_options$breakStyle","shiftZeroValue","semiDiscreteInterval","stick","_getStick","breaksSize","reverse","breaksLength","cumulativeWidth","getSpiderTicks","setSpiderTicks","drawScaleBreaks","_rotateConstantLine","applyVisualRangeSetter","visualRangeSetter","categoriesSortingMethod"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 22.1.3\r\n * Build date: Mon Jun 13 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    smartFormatter as _format,\r\n    formatRange\r\n} from \"./smart_formatter\";\r\nimport {\r\n    patchFontOptions,\r\n    getVizRangeObject,\r\n    getLogExt as getLog,\r\n    raiseToExt as raiseTo,\r\n    valueOf,\r\n    rotateBBox,\r\n    getCategoriesInfo,\r\n    adjustVisualRange,\r\n    getAddFunction,\r\n    convertVisualRangeObject\r\n} from \"../core/utils\";\r\nimport {\r\n    isDefined,\r\n    isFunction,\r\n    isPlainObject,\r\n    type\r\n} from \"../../core/utils/type\";\r\nimport constants from \"./axes_constants\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport formatHelper from \"../../format_helper\";\r\nimport {\r\n    getParser\r\n} from \"../components/parse_utils\";\r\nimport {\r\n    tickGenerator\r\n} from \"./tick_generator\";\r\nimport {\r\n    Translator2D\r\n} from \"../translators/translator2d\";\r\nimport {\r\n    Range\r\n} from \"../translators/range\";\r\nimport {\r\n    tick\r\n} from \"./tick\";\r\nimport {\r\n    adjust\r\n} from \"../../core/utils/math\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport {\r\n    noop as _noop\r\n} from \"../../core/utils/common\";\r\nimport xyMethods from \"./xy_axes\";\r\nimport * as polarMethods from \"./polar_axes\";\r\nimport createConstantLine from \"./constant_line\";\r\nimport createStrip from \"./strip\";\r\nimport {\r\n    Deferred,\r\n    when\r\n} from \"../../core/utils/deferred\";\r\nimport {\r\n    calculateCanvasMargins,\r\n    measureLabels\r\n} from \"./axes_utils\";\r\nvar convertTicksToValues = constants.convertTicksToValues;\r\nvar _math = Math;\r\nvar _abs = _math.abs;\r\nvar _max = _math.max;\r\nvar _min = _math.min;\r\nvar _isArray = Array.isArray;\r\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\r\nvar MAX_GRID_BORDER_ADHENSION = 4;\r\nvar TOP = constants.top;\r\nvar BOTTOM = constants.bottom;\r\nvar LEFT = constants.left;\r\nvar RIGHT = constants.right;\r\nvar CENTER = constants.center;\r\nvar KEEP = \"keep\";\r\nvar SHIFT = \"shift\";\r\nvar RESET = \"reset\";\r\nvar ROTATE = \"rotate\";\r\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\r\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\r\nvar SCROLL_THRESHOLD = 5;\r\nvar MIN_BAR_MARGIN = 5;\r\nvar MAX_MARGIN_VALUE = .8;\r\nvar dateIntervals = {\r\n    day: 864e5,\r\n    week: 6048e5\r\n};\r\n\r\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\r\n    var _options$workWeek;\r\n    var {\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold\r\n    } = _ref;\r\n    return tickGenerator({\r\n        axisType: options.type,\r\n        dataType: options.dataType,\r\n        logBase: options.logarithmBase,\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold,\r\n        axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\r\n        minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\r\n        numberMultipliers: options.numberMultipliers,\r\n        calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\r\n        allowDecimals: options.allowDecimals,\r\n        endOnTick: options.endOnTick,\r\n        incidentOccurred: incidentOccurred,\r\n        firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\r\n        skipTickGeneration: skipTickGeneration,\r\n        skipCalculationLimits: options.skipCalculationLimits,\r\n        generateExtraTick: options.generateExtraTick,\r\n        minTickInterval: options.minTickInterval,\r\n        rangeIsEmpty: rangeIsEmpty\r\n    })\r\n}\r\n\r\nfunction createMajorTick(axis, renderer, skippedCategory) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, options.tick, options.grid, skippedCategory, false)\r\n}\r\n\r\nfunction createMinorTick(axis, renderer) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, options.minorTick, options.minorGrid)\r\n}\r\n\r\nfunction createBoundaryTick(axis, renderer, isFirst) {\r\n    var options = axis.getOptions();\r\n    return tick(axis, renderer, extend({}, options.tick, {\r\n        visible: options.showCustomBoundaryTicks\r\n    }), options.grid, void 0, false, isFirst ? -1 : 1)\r\n}\r\n\r\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\r\n    (elements || []).forEach(e => e[action](actionArgument1, actionArgument2))\r\n}\r\n\r\nfunction initTickCoords(ticks) {\r\n    callAction(ticks, \"initCoords\")\r\n}\r\n\r\nfunction drawTickMarks(ticks, options) {\r\n    callAction(ticks, \"drawMark\", options)\r\n}\r\n\r\nfunction drawGrids(ticks, drawLine) {\r\n    callAction(ticks, \"drawGrid\", drawLine)\r\n}\r\n\r\nfunction updateTicksPosition(ticks, options, animate) {\r\n    callAction(ticks, \"updateTickPosition\", options, animate)\r\n}\r\n\r\nfunction updateGridsPosition(ticks, animate) {\r\n    callAction(ticks, \"updateGridPosition\", animate)\r\n}\r\n\r\nfunction cleanUpInvalidTicks(ticks) {\r\n    var i = ticks.length - 1;\r\n    for (i; i >= 0; i--) {\r\n        if (!removeInvalidTick(ticks, i)) {\r\n            break\r\n        }\r\n    }\r\n    for (i = 0; i < ticks.length; i++) {\r\n        if (removeInvalidTick(ticks, i)) {\r\n            i--\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeInvalidTick(ticks, i) {\r\n    if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\r\n        ticks.splice(i, 1);\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nfunction validateAxisOptions(options) {\r\n    var _labelOptions$minSpac;\r\n    var labelOptions = options.label;\r\n    var position = options.position;\r\n    var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\r\n    var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\r\n    var labelPosition = labelOptions.position;\r\n    if (position !== defaultPosition && position !== secondaryPosition) {\r\n        position = defaultPosition\r\n    }\r\n    if (!labelPosition || \"outside\" === labelPosition) {\r\n        labelPosition = position\r\n    } else if (\"inside\" === labelPosition) {\r\n        labelPosition = {\r\n            [TOP]: BOTTOM,\r\n            [BOTTOM]: TOP,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [position]\r\n    }\r\n    if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\r\n        labelPosition = position\r\n    }\r\n    if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\r\n        labelOptions.alignment = {\r\n            [TOP]: CENTER,\r\n            [BOTTOM]: CENTER,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [labelPosition]\r\n    }\r\n    options.position = position;\r\n    labelOptions.position = labelPosition;\r\n    options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\r\n    labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\r\n    options.type && (options.type = options.type.toLowerCase());\r\n    options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\r\n    options.valueType && (options.valueType = options.valueType.toLowerCase())\r\n}\r\n\r\nfunction getOptimalAngle(boxes, labelOpt) {\r\n    var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\r\n    return angle < 45 ? -45 : -90\r\n}\r\n\r\nfunction updateLabels(ticks, step, func) {\r\n    ticks.forEach((function(tick, index) {\r\n        if (tick.getContentContainer()) {\r\n            if (index % step !== 0) {\r\n                tick.removeLabel()\r\n            } else if (func) {\r\n                func(tick, index)\r\n            }\r\n        }\r\n    }))\r\n}\r\n\r\nfunction getZoomBoundValue(optionValue, dataValue) {\r\n    if (void 0 === optionValue) {\r\n        return dataValue\r\n    } else if (null === optionValue) {\r\n        return\r\n    } else {\r\n        return optionValue\r\n    }\r\n}\r\n\r\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\r\n    var tickGeneratorOptions = extend({}, options, {\r\n        endOnTick: true,\r\n        axisDivisionFactor: axisDivisionFactor,\r\n        skipCalculationLimits: true,\r\n        generateExtraTick: true,\r\n        minTickInterval: minTickInterval\r\n    });\r\n    return function(tickInterval, skipTickGeneration, min, max, breaks) {\r\n        return getTickGenerator(tickGeneratorOptions, _noop, skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({\r\n            min: min,\r\n            max: max,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, screenDelta, tickInterval, isDefined(tickInterval), void 0, void 0, void 0, breaks)\r\n    }\r\n}\r\n\r\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\r\n    return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1\r\n}\r\nexport var Axis = function(renderSettings) {\r\n    this._renderer = renderSettings.renderer;\r\n    this._incidentOccurred = renderSettings.incidentOccurred;\r\n    this._eventTrigger = renderSettings.eventTrigger;\r\n    this._stripsGroup = renderSettings.stripsGroup;\r\n    this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\r\n    this._labelsAxesGroup = renderSettings.labelsAxesGroup;\r\n    this._constantLinesGroup = renderSettings.constantLinesGroup;\r\n    this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\r\n    this._axesContainerGroup = renderSettings.axesContainerGroup;\r\n    this._gridContainerGroup = renderSettings.gridGroup;\r\n    this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\r\n    this._setType(renderSettings.axisType, renderSettings.drawingType);\r\n    this._createAxisGroups();\r\n    this._translator = this._createTranslator();\r\n    this.isArgumentAxis = renderSettings.isArgumentAxis;\r\n    this._viewport = {};\r\n    this._prevDataInfo = {};\r\n    this._firstDrawing = true;\r\n    this._initRange = {};\r\n    this._getTemplate = renderSettings.getTemplate\r\n};\r\nAxis.prototype = {\r\n    constructor: Axis,\r\n    _drawAxis() {\r\n        var options = this._options;\r\n        if (!options.visible) {\r\n            return\r\n        }\r\n        this._axisElement = this._createAxisElement();\r\n        this._updateAxisElementPosition();\r\n        this._axisElement.attr({\r\n            \"stroke-width\": options.width,\r\n            stroke: options.color,\r\n            \"stroke-opacity\": options.opacity\r\n        }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup)\r\n    },\r\n    _createPathElement(points, attr, sharpDirection) {\r\n        return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection)\r\n    },\r\n    sharp(svgElement) {\r\n        var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\r\n        return svgElement.sharp(this._getSharpParam(), sharpDirection)\r\n    },\r\n    customPositionIsAvailable: () => false,\r\n    getOrthogonalAxis: _noop,\r\n    getCustomPosition: _noop,\r\n    getCustomBoundaryPosition: _noop,\r\n    resolveOverlappingForCustomPositioning: _noop,\r\n    hasNonBoundaryPosition: () => false,\r\n    customPositionIsBoundaryOrthogonalAxis: () => false,\r\n    getResolvedBoundaryPosition() {\r\n        return this.getOptions().position\r\n    },\r\n    getAxisSharpDirection() {\r\n        var position = this.getResolvedBoundaryPosition();\r\n        return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1\r\n    },\r\n    getSharpDirectionByCoords(coords) {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var maxCoord = Math.max(canvas.start, canvas.end);\r\n        return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1\r\n    },\r\n    _getGridLineDrawer: function() {\r\n        var that = this;\r\n        return function(tick, gridStyle) {\r\n            var grid = that._getGridPoints(tick.coords);\r\n            if (grid.points) {\r\n                return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords))\r\n            }\r\n            return null\r\n        }\r\n    },\r\n    _getGridPoints: function(coords) {\r\n        var isHorizontal = this._isHorizontal;\r\n        var tickPositionField = isHorizontal ? \"x\" : \"y\";\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        var borderOptions = this.borderOptions;\r\n        var canvasStart = isHorizontal ? LEFT : TOP;\r\n        var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\r\n        var axisCanvas = this.getCanvas();\r\n        var canvas = {\r\n            left: axisCanvas.left,\r\n            right: axisCanvas.width - axisCanvas.right,\r\n            top: axisCanvas.top,\r\n            bottom: axisCanvas.height - axisCanvas.bottom\r\n        };\r\n        var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\r\n        var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\r\n        var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\r\n        var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\r\n        if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\r\n            return {\r\n                points: null\r\n            }\r\n        }\r\n        return {\r\n            points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\r\n        }\r\n    },\r\n    _getConstantLinePos: function(parsedValue, canvasStart, canvasEnd) {\r\n        var value = this._getTranslatedCoord(parsedValue);\r\n        if (!isDefined(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\r\n            return\r\n        }\r\n        return value\r\n    },\r\n    _getConstantLineGraphicAttributes: function(value) {\r\n        var positionFrom = this._orthogonalPositions.start;\r\n        var positionTo = this._orthogonalPositions.end;\r\n        return {\r\n            points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\r\n        }\r\n    },\r\n    _createConstantLine: function(value, attr) {\r\n        return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()))\r\n    },\r\n    _drawConstantLineLabelText: function(text, x, y, _ref2, group) {\r\n        var {\r\n            font: font,\r\n            cssClass: cssClass\r\n        } = _ref2;\r\n        return this._renderer.text(text, x, y).css(patchFontOptions(extend({}, this._options.label.font, font))).attr({\r\n            align: \"center\",\r\n            class: cssClass\r\n        }).append(group)\r\n    },\r\n    _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value, group) {\r\n        var _text;\r\n        var text = lineLabelOptions.text;\r\n        var options = this._options;\r\n        var labelOptions = options.label;\r\n        this._checkAlignmentConstantLineLabels(lineLabelOptions);\r\n        text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\r\n        var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\r\n        return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group)\r\n    },\r\n    _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {\r\n        var isContinuous = !!(range.minVisible || range.maxVisible);\r\n        var categories = (range.categories || []).reduce((function(result, cat) {\r\n            result.push(cat.valueOf());\r\n            return result\r\n        }), []);\r\n        var start;\r\n        var end;\r\n        var swap;\r\n        var startCategoryIndex;\r\n        var endCategoryIndex;\r\n        if (!isContinuous) {\r\n            if (isDefined(startValue) && isDefined(endValue)) {\r\n                var _parsedStartValue$val, _parsedEndValue$value;\r\n                var parsedStartValue = this.parser(startValue);\r\n                var parsedEndValue = this.parser(endValue);\r\n                startCategoryIndex = categories.indexOf(null !== (_parsedStartValue$val = null === parsedStartValue || void 0 === parsedStartValue ? void 0 : parsedStartValue.valueOf()) && void 0 !== _parsedStartValue$val ? _parsedStartValue$val : void 0);\r\n                endCategoryIndex = categories.indexOf(null !== (_parsedEndValue$value = null === parsedEndValue || void 0 === parsedEndValue ? void 0 : parsedEndValue.valueOf()) && void 0 !== _parsedEndValue$value ? _parsedEndValue$value : void 0);\r\n                if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\r\n                    return {\r\n                        from: 0,\r\n                        to: 0,\r\n                        outOfCanvas: true\r\n                    }\r\n                }\r\n                if (startCategoryIndex > endCategoryIndex) {\r\n                    swap = endValue;\r\n                    endValue = startValue;\r\n                    startValue = swap\r\n                }\r\n            }\r\n        }\r\n        if (isDefined(startValue)) {\r\n            startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\r\n            start = this._getTranslatedCoord(startValue, -1)\r\n        } else {\r\n            start = canvasStart\r\n        }\r\n        if (isDefined(endValue)) {\r\n            endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\r\n            end = this._getTranslatedCoord(endValue, 1)\r\n        } else {\r\n            end = canvasEnd\r\n        }\r\n        var stripPosition = start < end ? {\r\n            from: start,\r\n            to: end\r\n        } : {\r\n            from: end,\r\n            to: start\r\n        };\r\n        var visibleArea = this.getVisibleArea();\r\n        if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\r\n            stripPosition.outOfCanvas = true\r\n        }\r\n        return stripPosition\r\n    },\r\n    _getStripGraphicAttributes: function(fromPoint, toPoint) {\r\n        var x;\r\n        var y;\r\n        var width;\r\n        var height;\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        if (this._isHorizontal) {\r\n            x = fromPoint;\r\n            y = _min(positionFrom, positionTo);\r\n            width = toPoint - fromPoint;\r\n            height = _abs(positionFrom - positionTo)\r\n        } else {\r\n            x = _min(positionFrom, positionTo);\r\n            y = fromPoint;\r\n            width = _abs(positionFrom - positionTo);\r\n            height = _abs(fromPoint - toPoint)\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            width: width,\r\n            height: height\r\n        }\r\n    },\r\n    _createStrip: function(attrs) {\r\n        return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height)\r\n    },\r\n    _adjustStripLabels: function() {\r\n        var that = this;\r\n        this._strips.forEach((function(strip) {\r\n            if (strip.label) {\r\n                strip.label.attr(that._getAdjustedStripLabelCoords(strip))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\r\n        var getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\r\n        this._majorTicks.forEach((function(tick) {\r\n            if (tick.label) {\r\n                tick.updateMultilineTextAlignment();\r\n                tick.label.attr(getContainerAttrs(tick))\r\n            } else {\r\n                tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabels: function(offset) {\r\n        var options = this.getOptions();\r\n        var positionsAreConsistent = options.position === options.label.position;\r\n        var maxSize = this._majorTicks.reduce((function(size, tick) {\r\n            if (!tick.getContentContainer()) {\r\n                return size\r\n            }\r\n            var bBox = tick.labelRotationAngle ? rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\r\n            return {\r\n                width: _max(size.width || 0, bBox.width),\r\n                height: _max(size.height || 0, bBox.height),\r\n                offset: _max(size.offset || 0, tick.labelOffset || 0)\r\n            }\r\n        }), {});\r\n        var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\r\n        this._adjustLabelsCoord(offset, maxSize.width);\r\n        return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0)\r\n    },\r\n    _getLabelAdjustedCoord: function(tick, offset, maxWidth) {\r\n        offset = offset || 0;\r\n        var options = this._options;\r\n        var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\r\n        var box = templateBox || rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\r\n        var textAlign = tick.labelAlignment || options.label.alignment;\r\n        var isDiscrete = \"discrete\" === this._options.type;\r\n        var isFlatLabel = tick.labelRotationAngle % 90 === 0;\r\n        var indentFromAxis = options.label.indentFromAxis;\r\n        var labelPosition = options.label.position;\r\n        var axisPosition = this._axisPosition;\r\n        var labelCoords = tick.labelCoords;\r\n        var labelX = labelCoords.x;\r\n        var translateX;\r\n        var translateY;\r\n        if (this._isHorizontal) {\r\n            if (labelPosition === BOTTOM) {\r\n                translateY = axisPosition + indentFromAxis - box.y + offset\r\n            } else {\r\n                translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset\r\n            }\r\n            if (textAlign === RIGHT) {\r\n                translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width\r\n            } else if (textAlign === LEFT) {\r\n                translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x\r\n            } else {\r\n                translateX = labelX - box.x - box.width / 2\r\n            }\r\n        } else {\r\n            translateY = labelCoords.y - box.y - box.height / 2;\r\n            if (labelPosition === LEFT) {\r\n                if (textAlign === LEFT) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth - box.x\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition - indentFromAxis - box.x - box.width\r\n                }\r\n                translateX -= offset\r\n            } else {\r\n                if (textAlign === RIGHT) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition + indentFromAxis - box.x\r\n                }\r\n                translateX += offset\r\n            }\r\n        }\r\n        return {\r\n            translateX: translateX,\r\n            translateY: translateY\r\n        }\r\n    },\r\n    _createAxisConstantLineGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        var constantLinesClass = classSelector + \"constant-lines\";\r\n        var insideGroup = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup1 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup2 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        return {\r\n            inside: insideGroup,\r\n            outside1: outsideGroup1,\r\n            left: outsideGroup1,\r\n            top: outsideGroup1,\r\n            outside2: outsideGroup2,\r\n            right: outsideGroup2,\r\n            bottom: outsideGroup2,\r\n            remove: function() {\r\n                this.inside.remove();\r\n                this.outside1.remove();\r\n                this.outside2.remove()\r\n            },\r\n            clear: function() {\r\n                this.inside.clear();\r\n                this.outside1.clear();\r\n                this.outside2.clear()\r\n            }\r\n        }\r\n    },\r\n    _createAxisGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        this._axisGroup = renderer.g().attr({\r\n            class: classSelector + \"axis\"\r\n        }).enableLinks();\r\n        this._axisStripGroup = renderer.g().attr({\r\n            class: classSelector + \"strips\"\r\n        });\r\n        this._axisGridGroup = renderer.g().attr({\r\n            class: classSelector + \"grid\"\r\n        });\r\n        this._axisElementsGroup = renderer.g().attr({\r\n            class: classSelector + \"elements\"\r\n        });\r\n        this._axisLineGroup = renderer.g().attr({\r\n            class: classSelector + \"line\"\r\n        }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\r\n        this._axisTitleGroup = renderer.g().attr({\r\n            class: classSelector + \"title\"\r\n        }).append(this._axisGroup);\r\n        this._axisConstantLineGroups = {\r\n            above: this._createAxisConstantLineGroups(),\r\n            under: this._createAxisConstantLineGroups()\r\n        };\r\n        this._axisStripLabelGroup = renderer.g().attr({\r\n            class: classSelector + \"axis-labels\"\r\n        })\r\n    },\r\n    _clearAxisGroups: function() {\r\n        this._axisGroup.remove();\r\n        this._axisStripGroup.remove();\r\n        this._axisStripLabelGroup.remove();\r\n        this._axisConstantLineGroups.above.remove();\r\n        this._axisConstantLineGroups.under.remove();\r\n        this._axisGridGroup.remove();\r\n        this._axisTitleGroup.clear();\r\n        if (!this._options.label.template || !this.isRendered()) {\r\n            this._axisElementsGroup.remove();\r\n            this._axisElementsGroup.clear()\r\n        }\r\n        this._axisLineGroup && this._axisLineGroup.clear();\r\n        this._axisStripGroup && this._axisStripGroup.clear();\r\n        this._axisGridGroup && this._axisGridGroup.clear();\r\n        this._axisConstantLineGroups.above.clear();\r\n        this._axisConstantLineGroups.under.clear();\r\n        this._axisStripLabelGroup && this._axisStripLabelGroup.clear()\r\n    },\r\n    _getLabelFormatObject: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        range = range || this._getViewportRange();\r\n        var formatObject = {\r\n            value: value,\r\n            valueText: _format(value, {\r\n                labelOptions: labelOptions,\r\n                ticks: ticks || convertTicksToValues(this._majorTicks),\r\n                tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\r\n                dataType: this._options.dataType,\r\n                logarithmBase: this._options.logarithmBase,\r\n                type: this._options.type,\r\n                showTransition: !this._options.marker.visible,\r\n                point: point\r\n            }) || \"\",\r\n            min: range.minVisible,\r\n            max: range.maxVisible\r\n        };\r\n        if (point) {\r\n            formatObject.point = point\r\n        }\r\n        return formatObject\r\n    },\r\n    formatLabel: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\r\n        return isFunction(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText\r\n    },\r\n    formatHint: function(value, labelOptions, range) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range);\r\n        return isFunction(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0\r\n    },\r\n    formatRange(startValue, endValue, interval, argumentFormat) {\r\n        return formatRange({\r\n            startValue: startValue,\r\n            endValue: endValue,\r\n            tickInterval: interval,\r\n            argumentFormat: argumentFormat,\r\n            axisOptions: this.getOptions()\r\n        })\r\n    },\r\n    _setTickOffset: function() {\r\n        var options = this._options;\r\n        var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\r\n        this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode)\r\n    },\r\n    aggregatedPointBetweenTicks() {\r\n        return \"crossTicks\" === this._options.aggregatedPointsPosition\r\n    },\r\n    resetApplyingAnimation: function(isFirstDrawing) {\r\n        this._resetApplyingAnimation = true;\r\n        if (isFirstDrawing) {\r\n            this._firstDrawing = true\r\n        }\r\n    },\r\n    isFirstDrawing() {\r\n        return this._firstDrawing\r\n    },\r\n    getMargins: function() {\r\n        var that = this;\r\n        var {\r\n            position: position,\r\n            offset: offset,\r\n            customPosition: customPosition,\r\n            placeholderSize: placeholderSize,\r\n            grid: grid,\r\n            tick: tick,\r\n            crosshairMargin: crosshairMargin\r\n        } = that._options;\r\n        var isDefinedCustomPositionOption = isDefined(customPosition);\r\n        var boundaryPosition = that.getResolvedBoundaryPosition();\r\n        var canvas = that.getCanvas();\r\n        var cLeft = canvas.left;\r\n        var cTop = canvas.top;\r\n        var cRight = canvas.width - canvas.right;\r\n        var cBottom = canvas.height - canvas.bottom;\r\n        var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\r\n        var constantLineAboveSeries = that._axisConstantLineGroups.above;\r\n        var constantLineUnderSeries = that._axisConstantLineGroups.under;\r\n        var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function(group) {\r\n            var box = group && group.getBBox();\r\n            if (!box || box.isEmpty) {\r\n                return box\r\n            }\r\n            if (that._isHorizontal) {\r\n                box.x = cLeft;\r\n                box.width = cRight - cLeft\r\n            } else {\r\n                box.y = cTop;\r\n                box.height = cBottom - cTop\r\n            }\r\n            return box\r\n        }(that._axisTitleGroup));\r\n        var margins = calculateCanvasMargins(boxes, canvas);\r\n        margins[position] += crosshairMargin;\r\n        if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\r\n            margins[boundaryPosition] = 0\r\n        }\r\n        if (placeholderSize) {\r\n            margins[position] = placeholderSize\r\n        }\r\n        if (edgeMarginCorrection) {\r\n            if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\r\n                margins.right = edgeMarginCorrection\r\n            }\r\n            if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\r\n                margins.bottom = edgeMarginCorrection\r\n            }\r\n        }\r\n        if (!isDefinedCustomPositionOption && isDefined(offset)) {\r\n            var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\r\n            margins[boundaryPosition] -= moveByOffset ? offset : 0\r\n        }\r\n        return margins\r\n    },\r\n    validateUnit: function(unit, idError, parameters) {\r\n        unit = this.parser(unit);\r\n        if (void 0 === unit && idError) {\r\n            this._incidentOccurred(idError, [parameters])\r\n        }\r\n        return unit\r\n    },\r\n    _setType: function(axisType, drawingType) {\r\n        var axisTypeMethods;\r\n        switch (axisType) {\r\n            case \"xyAxes\":\r\n                axisTypeMethods = xyMethods;\r\n                break;\r\n            case \"polarAxes\":\r\n                axisTypeMethods = polarMethods\r\n        }\r\n        extend(this, axisTypeMethods[drawingType])\r\n    },\r\n    _getSharpParam: function() {\r\n        return true\r\n    },\r\n    _disposeBreaksGroup: _noop,\r\n    dispose: function() {\r\n        [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach((function(g) {\r\n            g.dispose()\r\n        }));\r\n        this._strips = this._title = null;\r\n        this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\r\n        this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\r\n        this._axisGroup = this._axisTitleGroup = null;\r\n        this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\r\n        this._renderer = this._options = this._textOptions = this._textFontStyles = null;\r\n        this._translator = null;\r\n        this._majorTicks = this._minorTicks = null;\r\n        this._disposeBreaksGroup();\r\n        this._templatesRendered && this._templatesRendered.reject()\r\n    },\r\n    getOptions: function() {\r\n        return this._options\r\n    },\r\n    setPane: function(pane) {\r\n        this.pane = pane;\r\n        this._options.pane = pane\r\n    },\r\n    setTypes: function(type, axisType, typeSelector) {\r\n        this._options.type = type || this._options.type;\r\n        this._options[typeSelector] = axisType || this._options[typeSelector];\r\n        this._updateTranslator()\r\n    },\r\n    resetTypes: function(typeSelector) {\r\n        this._options.type = this._initTypes.type;\r\n        this._options[typeSelector] = this._initTypes[typeSelector]\r\n    },\r\n    getTranslator: function() {\r\n        return this._translator\r\n    },\r\n    updateOptions: function(options) {\r\n        var that = this;\r\n        var labelOpt = options.label;\r\n        validateAxisOptions(options);\r\n        that._options = options;\r\n        options.tick = options.tick || {};\r\n        options.minorTick = options.minorTick || {};\r\n        options.grid = options.grid || {};\r\n        options.minorGrid = options.minorGrid || {};\r\n        options.title = options.title || {};\r\n        options.marker = options.marker || {};\r\n        that._initTypes = {\r\n            type: options.type,\r\n            argumentType: options.argumentType,\r\n            valueType: options.valueType\r\n        };\r\n        that._setTickOffset();\r\n        that._isHorizontal = options.isHorizontal;\r\n        that.pane = options.pane;\r\n        that.name = options.name;\r\n        that.priority = options.priority;\r\n        that._hasLabelFormat = \"\" !== labelOpt.format && isDefined(labelOpt.format);\r\n        that._textOptions = {\r\n            opacity: labelOpt.opacity,\r\n            align: \"center\",\r\n            class: labelOpt.cssClass\r\n        };\r\n        that._textFontStyles = patchFontOptions(labelOpt.font);\r\n        if (options.type === constants.logarithmic) {\r\n            if (options.logarithmBaseError) {\r\n                that._incidentOccurred(\"E2104\");\r\n                delete options.logarithmBaseError\r\n            }\r\n        }\r\n        that._updateTranslator();\r\n        that._createConstantLines();\r\n        that._strips = (options.strips || []).map(o => createStrip(that, o));\r\n        that._majorTicks = that._minorTicks = null;\r\n        that._firstDrawing = true\r\n    },\r\n    calculateInterval: function(value, prevValue) {\r\n        var options = this._options;\r\n        if (!options || options.type !== constants.logarithmic) {\r\n            return _abs(value - prevValue)\r\n        }\r\n        var {\r\n            allowNegatives: allowNegatives,\r\n            linearThreshold: linearThreshold\r\n        } = new Range(this.getTranslator().getBusinessRange());\r\n        return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold))\r\n    },\r\n    getCanvasRange() {\r\n        var translator = this._translator;\r\n        return {\r\n            startValue: translator.from(translator.translate(\"canvas_position_start\")),\r\n            endValue: translator.from(translator.translate(\"canvas_position_end\"))\r\n        }\r\n    },\r\n    _processCanvas: function(canvas) {\r\n        return canvas\r\n    },\r\n    updateCanvas: function(canvas, canvasRedesign) {\r\n        if (!canvasRedesign) {\r\n            var positions = this._orthogonalPositions = {\r\n                start: !this._isHorizontal ? canvas.left : canvas.top,\r\n                end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\r\n            };\r\n            positions.center = positions.start + (positions.end - positions.start) / 2\r\n        } else {\r\n            this._orthogonalPositions = null\r\n        }\r\n        this._canvas = canvas;\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        this._initAxisPositions()\r\n    },\r\n    getCanvas: function() {\r\n        return this._canvas\r\n    },\r\n    getAxisShift() {\r\n        return this._axisShift || 0\r\n    },\r\n    hideTitle: function() {\r\n        if (this._options.title.text) {\r\n            this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisTitleGroup.clear()\r\n        }\r\n    },\r\n    getTitle: function() {\r\n        return this._title\r\n    },\r\n    hideOuterElements: function() {\r\n        var options = this._options;\r\n        if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\r\n            this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisElementsGroup.clear();\r\n            callAction(this._outsideConstantLines, \"removeLabel\")\r\n        }\r\n    },\r\n    _resolveLogarithmicOptionsForRange(range) {\r\n        var options = this._options;\r\n        if (options.type === constants.logarithmic) {\r\n            range.addRange({\r\n                allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\r\n            });\r\n            if (!isNaN(options.linearThreshold)) {\r\n                range.linearThreshold = options.linearThreshold\r\n            }\r\n        }\r\n    },\r\n    adjustViewport(businessRange) {\r\n        var options = this._options;\r\n        var isDiscrete = options.type === constants.discrete;\r\n        var categories = this._seriesData && this._seriesData.categories || [];\r\n        var wholeRange = this.adjustRange(getVizRangeObject(options.wholeRange));\r\n        var visualRange = this.getViewport() || {};\r\n        var result = new Range(businessRange);\r\n        this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\r\n        var minDefined = isDefined(visualRange.startValue);\r\n        var maxDefined = isDefined(visualRange.endValue);\r\n        if (!isDiscrete) {\r\n            minDefined = minDefined && (!isDefined(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\r\n            maxDefined = maxDefined && (!isDefined(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue)\r\n        }\r\n        var minVisible = minDefined ? visualRange.startValue : result.minVisible;\r\n        var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\r\n        if (!isDiscrete) {\r\n            var _wholeRange$startValu, _wholeRange$endValue;\r\n            result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\r\n            result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max\r\n        } else {\r\n            var categoriesInfo = getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\r\n            categories = categoriesInfo.categories;\r\n            result.categories = categories\r\n        }\r\n        var adjustedVisualRange = adjustVisualRange({\r\n            axisType: options.type,\r\n            dataType: options.dataType,\r\n            base: options.logarithmBase\r\n        }, {\r\n            startValue: minDefined ? visualRange.startValue : void 0,\r\n            endValue: maxDefined ? visualRange.endValue : void 0,\r\n            length: visualRange.length\r\n        }, {\r\n            categories: categories,\r\n            min: wholeRange.startValue,\r\n            max: wholeRange.endValue\r\n        }, {\r\n            categories: categories,\r\n            min: minVisible,\r\n            max: maxVisible\r\n        });\r\n        result.minVisible = adjustedVisualRange.startValue;\r\n        result.maxVisible = adjustedVisualRange.endValue;\r\n        !isDefined(result.min) && (result.min = result.minVisible);\r\n        !isDefined(result.max) && (result.max = result.maxVisible);\r\n        result.addRange({});\r\n        this._resolveLogarithmicOptionsForRange(result);\r\n        return result\r\n    },\r\n    adjustRange(range) {\r\n        range = range || {};\r\n        var isDiscrete = this._options.type === constants.discrete;\r\n        var isLogarithmic = this._options.type === constants.logarithmic;\r\n        var disabledNegatives = false === this._options.allowNegatives;\r\n        if (isLogarithmic) {\r\n            range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\r\n            range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue\r\n        }\r\n        if (!isDiscrete && isDefined(range.startValue) && isDefined(range.endValue) && range.startValue > range.endValue) {\r\n            var tmp = range.endValue;\r\n            range.endValue = range.startValue;\r\n            range.startValue = tmp\r\n        }\r\n        return range\r\n    },\r\n    _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\r\n        var value = this._options.visualRangeUpdateMode;\r\n        var translator = this._translator;\r\n        var range = this._seriesData;\r\n        var prevDataInfo = this._prevDataInfo;\r\n        if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {\r\n            return KEEP\r\n        }\r\n        if (!this.isArgumentAxis) {\r\n            var _viewport = this.getViewport();\r\n            if (!isDefined(_viewport.startValue) && !isDefined(_viewport.endValue) && !isDefined(_viewport.length)) {\r\n                return RESET\r\n            }\r\n        }\r\n        if (this.isArgumentAxis) {\r\n            if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\r\n                if (range.axisType === constants.discrete) {\r\n                    var categories = range.categories;\r\n                    var newCategories = newRange.categories;\r\n                    var visualRange = this.visualRange();\r\n                    if (categories && newCategories && categories.length && -1 !== newCategories.map(c => c.valueOf()).join(\",\").indexOf(categories.map(c => c.valueOf()).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\r\n                        value = KEEP\r\n                    } else {\r\n                        value = RESET\r\n                    }\r\n                } else {\r\n                    var minPoint = translator.translate(range.min);\r\n                    var minVisiblePoint = translator.translate(viewport.startValue);\r\n                    var maxPoint = translator.translate(range.max);\r\n                    var maxVisiblePoint = translator.translate(viewport.endValue);\r\n                    if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = RESET\r\n                    } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = SHIFT\r\n                    } else {\r\n                        value = KEEP\r\n                    }\r\n                }\r\n                if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {\r\n                    value = RESET\r\n                }\r\n            }\r\n        } else if (-1 === [KEEP, RESET].indexOf(value)) {\r\n            if (oppositeValue === KEEP) {\r\n                value = KEEP\r\n            } else {\r\n                value = RESET\r\n            }\r\n        }\r\n        return value\r\n    },\r\n    _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\r\n        var visualRange = this.visualRange();\r\n        if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\r\n            return\r\n        }\r\n        var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\r\n        if (visualRangeUpdateMode === KEEP) {\r\n            this._setVisualRange([visualRange.startValue, visualRange.endValue])\r\n        } else if (visualRangeUpdateMode === RESET) {\r\n            this._setVisualRange([null, null])\r\n        } else if (visualRangeUpdateMode === SHIFT) {\r\n            this._setVisualRange({\r\n                length: this.getVisualRangeLength()\r\n            })\r\n        }\r\n    },\r\n    getVisualRangeLength(range) {\r\n        var currentBusinessRange = range || this._translator.getBusinessRange();\r\n        var {\r\n            type: type\r\n        } = this._options;\r\n        var length;\r\n        if (type === constants.logarithmic) {\r\n            length = adjust(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible))\r\n        } else if (type === constants.discrete) {\r\n            var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            length = categoriesInfo.categories.length\r\n        } else {\r\n            length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible\r\n        }\r\n        return length\r\n    },\r\n    getVisualRangeCenter(range, useMerge) {\r\n        var translator = this.getTranslator();\r\n        var businessRange = translator.getBusinessRange();\r\n        var currentBusinessRange = useMerge ? extend(true, {}, businessRange, range || {}) : range || businessRange;\r\n        var {\r\n            type: type,\r\n            logarithmBase: logarithmBase\r\n        } = this._options;\r\n        var center;\r\n        if (!isDefined(currentBusinessRange.minVisible) || !isDefined(currentBusinessRange.maxVisible)) {\r\n            return\r\n        }\r\n        if (type === constants.logarithmic) {\r\n            var {\r\n                allowNegatives: allowNegatives,\r\n                linearThreshold: linearThreshold,\r\n                minVisible: minVisible,\r\n                maxVisible: maxVisible\r\n            } = currentBusinessRange;\r\n            center = raiseTo(adjust(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold)\r\n        } else if (type === constants.discrete) {\r\n            var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\r\n            center = businessRange.categories.indexOf(categoriesInfo.categories[index])\r\n        } else {\r\n            center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2)\r\n        }\r\n        return center\r\n    },\r\n    setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\r\n        var _that$_seriesData$min, _that$_seriesData$max;\r\n        var options = this._options;\r\n        var isDiscrete = options.type === constants.discrete;\r\n        this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\r\n        this._seriesData = new Range(range);\r\n        var dataIsEmpty = this._seriesData.isEmpty();\r\n        var rangeWithConstantLines = new Range(this._seriesData);\r\n        this._addConstantLinesToRange(rangeWithConstantLines, \"minVisible\", \"maxVisible\");\r\n        this._prevDataInfo = {\r\n            isEmpty: dataIsEmpty,\r\n            containsConstantLine: rangeWithConstantLines.containsConstantLine\r\n        };\r\n        this._seriesData.addRange({\r\n            categories: options.categories,\r\n            dataType: options.dataType,\r\n            axisType: options.type,\r\n            base: options.logarithmBase,\r\n            invert: options.inverted\r\n        });\r\n        this._resolveLogarithmicOptionsForRange(this._seriesData);\r\n        if (!isDiscrete) {\r\n            if (!isDefined(this._seriesData.min) && !isDefined(this._seriesData.max)) {\r\n                var visualRange = this.getViewport();\r\n                visualRange && this._seriesData.addRange({\r\n                    min: visualRange.startValue,\r\n                    max: visualRange.endValue\r\n                })\r\n            }\r\n            var synchronizedValue = options.synchronizedValue;\r\n            if (isDefined(synchronizedValue)) {\r\n                this._seriesData.addRange({\r\n                    min: synchronizedValue,\r\n                    max: synchronizedValue\r\n                })\r\n            }\r\n        }\r\n        this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\r\n        this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\r\n        if (!this.isArgumentAxis && options.showZero) {\r\n            this._seriesData.correctValueZeroLevel()\r\n        }\r\n        this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\r\n        this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {\r\n            if (cl.options.extendAxis) {\r\n                var value = cl.getParsedValue();\r\n                dataRange.addRange({\r\n                    containsConstantLine: true,\r\n                    [minValueField]: value,\r\n                    [maxValueField]: value\r\n                })\r\n            }\r\n        })\r\n    },\r\n    setGroupSeries: function(series) {\r\n        this._series = series\r\n    },\r\n    getLabelsPosition: function() {\r\n        var options = this._options;\r\n        var position = options.position;\r\n        var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\r\n        var axisPosition = this._axisPosition;\r\n        return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift\r\n    },\r\n    getFormattedValue: function(value, options, point) {\r\n        var labelOptions = this._options.label;\r\n        return isDefined(value) ? this.formatLabel(value, extend(true, {}, labelOptions, options), void 0, point) : null\r\n    },\r\n    _getBoundaryTicks: function(majors, viewPort) {\r\n        var length = majors.length;\r\n        var options = this._options;\r\n        var customBounds = options.customBoundTicks;\r\n        var min = viewPort.minVisible;\r\n        var max = viewPort.maxVisible;\r\n        var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\r\n        var boundaryTicks = [];\r\n        if (options.type === constants.discrete) {\r\n            if (this._tickOffset && 0 !== majors.length) {\r\n                boundaryTicks = [majors[0], majors[majors.length - 1]]\r\n            }\r\n        } else if (customBounds) {\r\n            if (addMinMax.min && isDefined(customBounds[0])) {\r\n                boundaryTicks.push(customBounds[0])\r\n            }\r\n            if (addMinMax.max && isDefined(customBounds[1])) {\r\n                boundaryTicks.push(customBounds[1])\r\n            }\r\n        } else {\r\n            if (addMinMax.min && (0 === length || majors[0] > min)) {\r\n                boundaryTicks.push(min)\r\n            }\r\n            if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\r\n                boundaryTicks.push(max)\r\n            }\r\n        }\r\n        return boundaryTicks\r\n    },\r\n    setPercentLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            this._options.label.format = \"percent\"\r\n        }\r\n    },\r\n    resetAutoLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            delete this._options.label.format\r\n        }\r\n    },\r\n    getMultipleAxesSpacing: function() {\r\n        return this._options.multipleAxesSpacing || 0\r\n    },\r\n    getTicksValues: function() {\r\n        return {\r\n            majorTicksValues: convertTicksToValues(this._majorTicks),\r\n            minorTicksValues: convertTicksToValues(this._minorTicks)\r\n        }\r\n    },\r\n    estimateTickInterval: function(canvas) {\r\n        this.updateCanvas(canvas);\r\n        return this._tickInterval !== this._getTicks(this._getViewportRange(), _noop, true).tickInterval\r\n    },\r\n    setTicks: function(ticks) {\r\n        var majors = ticks.majorTicks || [];\r\n        this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\r\n        this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\r\n        this._isSynchronized = true\r\n    },\r\n    _adjustDivisionFactor: function(val) {\r\n        return val\r\n    },\r\n    _getTicks: function(viewPort, incidentOccurred, skipTickGeneration) {\r\n        var options = this._options;\r\n        var customTicks = options.customTicks;\r\n        var customMinorTicks = options.customMinorTicks;\r\n        return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\r\n            min: viewPort.minVisible,\r\n            max: viewPort.maxVisible,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\r\n            majors: customTicks,\r\n            minors: customMinorTicks\r\n        }, options.minorTickInterval, options.minorTickCount, this._initialBreaks)\r\n    },\r\n    _createTicksAndLabelFormat: function(range, incidentOccurred) {\r\n        var options = this._options;\r\n        var ticks = this._getTicks(range, incidentOccurred, false);\r\n        if (!range.isEmpty() && options.type === constants.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\r\n            options.label.format = formatHelper.getDateFormatByTicks(ticks.ticks)\r\n        }\r\n        return ticks\r\n    },\r\n    getAggregationInfo(useAllAggregatedPoints, range) {\r\n        var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\r\n        var options = this._options;\r\n        var marginOptions = this._marginOptions;\r\n        var businessRange = new Range(this.getTranslator().getBusinessRange()).addRange(range);\r\n        var visualRange = this.getViewport();\r\n        var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\r\n        var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\r\n        var ticks = [];\r\n        if (options.type === constants.discrete && options.aggregateByCategory) {\r\n            return {\r\n                aggregateByCategory: true\r\n            }\r\n        }\r\n        var aggregationInterval = options.aggregationInterval;\r\n        var aggregationGroupWidth = options.aggregationGroupWidth;\r\n        if (!aggregationGroupWidth && marginOptions) {\r\n            if (marginOptions.checkInterval) {\r\n                aggregationGroupWidth = options.axisDivisionFactor\r\n            }\r\n            if (marginOptions.sizePointNormalState) {\r\n                aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor)\r\n            }\r\n        }\r\n        var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\r\n        var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\r\n        var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\r\n        if (options.type !== constants.discrete) {\r\n            var min = useAllAggregatedPoints ? businessRange.min : minVisible;\r\n            var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\r\n            if (isDefined(min) && isDefined(max)) {\r\n                var add = getAddFunction({\r\n                    base: options.logarithmBase,\r\n                    axisType: options.type,\r\n                    dataType: options.dataType\r\n                }, false);\r\n                var start = min;\r\n                var end = max;\r\n                if (!useAllAggregatedPoints) {\r\n                    var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\r\n                    start = add(min, maxMinDistance, -1);\r\n                    end = add(max, maxMinDistance)\r\n                }\r\n                start = start < businessRange.min ? businessRange.min : start;\r\n                end = end > businessRange.max ? businessRange.max : end;\r\n                var breaks = this._getScaleBreaks(options, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, this._series, this.isArgumentAxis);\r\n                var filteredBreaks = this._filterBreaks(breaks, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, options.breakStyle);\r\n                ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks\r\n            }\r\n        }\r\n        this._aggregationInterval = tickInterval;\r\n        return {\r\n            interval: tickInterval,\r\n            ticks: ticks\r\n        }\r\n    },\r\n    getTickInterval() {\r\n        return this._tickInterval\r\n    },\r\n    getAggregationInterval() {\r\n        return this._aggregationInterval\r\n    },\r\n    createTicks: function(canvas) {\r\n        var that = this;\r\n        var renderer = that._renderer;\r\n        var options = that._options;\r\n        if (!canvas) {\r\n            return\r\n        }\r\n        that._isSynchronized = false;\r\n        that.updateCanvas(canvas);\r\n        var range = that._getViewportRange();\r\n        that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\r\n        that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _noop, true).tickInterval;\r\n        var margins = this._calculateValueMargins();\r\n        range.addRange({\r\n            minVisible: margins.minValue,\r\n            maxVisible: margins.maxValue,\r\n            isSpacedMargin: margins.isSpacedMargin\r\n        });\r\n        var ticks = that._createTicksAndLabelFormat(range);\r\n        var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\r\n        if (options.showCustomBoundaryTicks && boundaryTicks.length) {\r\n            that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\r\n            if (boundaryTicks.length > 1) {\r\n                that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)))\r\n            }\r\n        } else {\r\n            that._boundaryTicks = []\r\n        }\r\n        var minors = (ticks.minorTicks || []).filter((function(minor) {\r\n            return !boundaryTicks.some((function(boundary) {\r\n                return valueOf(boundary) === valueOf(minor)\r\n            }))\r\n        }));\r\n        that._tickInterval = ticks.tickInterval;\r\n        that._minorTickInterval = ticks.minorTickInterval;\r\n        var oldMajorTicks = that._majorTicks || [];\r\n        var majorTicksByValues = oldMajorTicks.reduce((r, t) => {\r\n            r[t.value.valueOf()] = t;\r\n            return r\r\n        }, {});\r\n        var sameType = type(ticks.ticks[0]) === type(oldMajorTicks[0] && oldMajorTicks[0].value);\r\n        var skippedCategory = that._getSkippedCategory(ticks.ticks);\r\n        var majorTicks = ticks.ticks.map(v => {\r\n            var tick = majorTicksByValues[v.valueOf()];\r\n            if (tick && sameType) {\r\n                delete majorTicksByValues[v.valueOf()];\r\n                tick.setSkippedCategory(skippedCategory);\r\n                return tick\r\n            } else {\r\n                return createMajorTick(that, renderer, skippedCategory)(v)\r\n            }\r\n        });\r\n        that._majorTicks = majorTicks;\r\n        var oldMinorTicks = that._minorTicks || [];\r\n        that._minorTicks = minors.map((v, i) => {\r\n            var minorTick = oldMinorTicks[i];\r\n            if (minorTick) {\r\n                minorTick.updateValue(v);\r\n                return minorTick\r\n            }\r\n            return createMinorTick(that, renderer)(v)\r\n        });\r\n        that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\r\n        that._ticksToRemove.forEach(t => {\r\n            var _t$label;\r\n            return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle()\r\n        });\r\n        if (ticks.breaks) {\r\n            that._seriesData.breaks = ticks.breaks\r\n        }\r\n        that._reinitTranslator(that._getViewportRange())\r\n    },\r\n    _reinitTranslator: function(range) {\r\n        var translator = this._translator;\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        translator.updateBusinessRange(range)\r\n    },\r\n    _getViewportRange() {\r\n        return this.adjustViewport(this._seriesData)\r\n    },\r\n    setMarginOptions: function(options) {\r\n        this._marginOptions = options\r\n    },\r\n    getMarginOptions() {\r\n        var _this$_marginOptions;\r\n        return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {}\r\n    },\r\n    _calculateRangeInterval: function(interval) {\r\n        var isDateTime = \"datetime\" === this._options.dataType;\r\n        var minArgs = [];\r\n        var addToArgs = function(value) {\r\n            isDefined(value) && minArgs.push(isDateTime ? dateUtils.dateToMilliseconds(value) : value)\r\n        };\r\n        addToArgs(this._tickInterval);\r\n        addToArgs(this._estimatedTickInterval);\r\n        isDefined(interval) && minArgs.push(interval);\r\n        addToArgs(this._aggregationInterval);\r\n        return this._calculateWorkWeekInterval(_min.apply(this, minArgs))\r\n    },\r\n    _calculateWorkWeekInterval(businessInterval) {\r\n        var options = this._options;\r\n        if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\r\n            var workWeek = options.workWeek.length * dateIntervals.day;\r\n            var weekend = dateIntervals.week - workWeek;\r\n            if (workWeek !== businessInterval && weekend < businessInterval) {\r\n                var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\r\n                businessInterval -= weekend * weekendsCount\r\n            } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\r\n                businessInterval = dateIntervals.day\r\n            }\r\n        }\r\n        return businessInterval\r\n    },\r\n    _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\r\n        var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\r\n        return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta))\r\n    },\r\n    _calculateValueMargins(ticks) {\r\n        this._resetMargins();\r\n        var margins = this.getMarginOptions();\r\n        var marginSize = (margins.size || 0) / 2;\r\n        var options = this._options;\r\n        var dataRange = this._getViewportRange();\r\n        var viewPort = this.getViewport();\r\n        var screenDelta = this._getScreenDelta();\r\n        var isDiscrete = -1 !== (options.type || \"\").indexOf(constants.discrete);\r\n        var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\r\n        var translator = this._translator;\r\n        var minValueMargin = options.minValueMargin;\r\n        var maxValueMargin = options.maxValueMargin;\r\n        var minPadding = 0;\r\n        var maxPadding = 0;\r\n        var interval = 0;\r\n        var rangeInterval;\r\n        if (dataRange.stubData || !screenDelta) {\r\n            return {\r\n                startPadding: 0,\r\n                endPadding: 0\r\n            }\r\n        }\r\n        if (this.isArgumentAxis && margins.checkInterval) {\r\n            rangeInterval = this._calculateRangeInterval(dataRange.interval);\r\n            var pxInterval = translator.getInterval(rangeInterval);\r\n            if (isFinite(pxInterval)) {\r\n                interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)))\r\n            } else {\r\n                rangeInterval = 0\r\n            }\r\n        }\r\n        var minPercentPadding;\r\n        var maxPercentPadding;\r\n        var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\r\n        if (valueMarginsEnabled) {\r\n            if (isDefined(minValueMargin)) {\r\n                minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {\r\n                minPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                minPadding = Math.max(marginSize, interval);\r\n                minPadding = Math.min(maxPaddingValue, minPadding)\r\n            }\r\n            if (isDefined(maxValueMargin)) {\r\n                maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {\r\n                maxPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                maxPadding = Math.max(marginSize, interval);\r\n                maxPadding = Math.min(maxPaddingValue, maxPadding)\r\n            }\r\n        }\r\n        var percentStick = margins.percentStick && !this.isArgumentAxis;\r\n        if (percentStick) {\r\n            if (1 === _abs(dataRange.max)) {\r\n                maxPadding = 0\r\n            }\r\n            if (1 === _abs(dataRange.min)) {\r\n                minPadding = 0\r\n            }\r\n        }\r\n        var canvasStartEnd = this._getCanvasStartEnd();\r\n        var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\r\n        var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\r\n        if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\r\n            if (void 0 !== minPercentPadding) {\r\n                minPadding = screenDeltaWithMargins * minPercentPadding\r\n            }\r\n            if (void 0 !== maxPercentPadding) {\r\n                maxPadding = screenDeltaWithMargins * maxPercentPadding\r\n            }\r\n        }\r\n        var minValue;\r\n        var maxValue;\r\n        if (options.type !== constants.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\r\n            var length = ticks.length;\r\n            var firstTickPosition = translator.translate(ticks[0].value);\r\n            var lastTickPosition = translator.translate(ticks[length - 1].value);\r\n            var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\r\n            var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\r\n            var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\r\n            if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\r\n                var commonPadding = maxTickPadding + minTickPadding;\r\n                var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\r\n                if (minTickPadding >= minPadding) {\r\n                    minValue = ticks[0].value\r\n                }\r\n                if (maxTickPadding >= maxPadding) {\r\n                    maxValue = ticks[length - 1].value\r\n                }\r\n                minPadding = _max(minTickPadding, minPadding) / coeff;\r\n                maxPadding = _max(maxTickPadding, maxPadding) / coeff\r\n            }\r\n        }\r\n        minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\r\n        maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\r\n        if (!isDiscrete) {\r\n            if (this._translator.isInverted()) {\r\n                var _minValue, _maxValue;\r\n                minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1)\r\n            } else {\r\n                var _minValue2, _maxValue2;\r\n                minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1)\r\n            }\r\n        }\r\n        var {\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax,\r\n            start: start,\r\n            end: end\r\n        } = this.getCorrectedValuesToZero(minValue, maxValue);\r\n        minPadding = null !== start && void 0 !== start ? start : minPadding;\r\n        maxPadding = null !== end && void 0 !== end ? end : maxPadding;\r\n        return {\r\n            startPadding: translator.isInverted() ? maxPadding : minPadding,\r\n            endPadding: translator.isInverted() ? minPadding : maxPadding,\r\n            minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\r\n            maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\r\n            interval: rangeInterval,\r\n            isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\r\n        }\r\n    },\r\n    getCorrectedValuesToZero(minValue, maxValue) {\r\n        var that = this;\r\n        var translator = that._translator;\r\n        var canvasStartEnd = that._getCanvasStartEnd();\r\n        var dataRange = that._getViewportRange();\r\n        var screenDelta = that._getScreenDelta();\r\n        var options = that._options;\r\n        var start;\r\n        var end;\r\n        var correctedMin;\r\n        var correctedMax;\r\n        var correctZeroLevel = (minPoint, maxPoint) => {\r\n            var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\r\n            var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\r\n            var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\r\n            start = minExpectedPadding / coeff;\r\n            end = maxExpectedPadding / coeff\r\n        };\r\n        if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\r\n            if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\r\n                correctZeroLevel(translator.translate(0), translator.translate(maxValue));\r\n                correctedMin = 0\r\n            }\r\n            if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\r\n                correctZeroLevel(translator.translate(minValue), translator.translate(0));\r\n                correctedMax = 0\r\n            }\r\n        }\r\n        return {\r\n            start: isFinite(start) ? start : null,\r\n            end: isFinite(end) ? end : null,\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax\r\n        }\r\n    },\r\n    applyMargins() {\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        var margins = this._calculateValueMargins(this._majorTicks);\r\n        var canvas = extend({}, this._canvas, {\r\n            startPadding: margins.startPadding,\r\n            endPadding: margins.endPadding\r\n        });\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        if (isFinite(margins.interval)) {\r\n            var br = this._translator.getBusinessRange();\r\n            br.addRange({\r\n                interval: margins.interval\r\n            });\r\n            this._translator.updateBusinessRange(br)\r\n        }\r\n    },\r\n    _resetMargins: function() {\r\n        this._reinitTranslator(this._getViewportRange());\r\n        if (this._canvas) {\r\n            this._translator.updateCanvas(this._processCanvas(this._canvas))\r\n        }\r\n    },\r\n    _createConstantLines() {\r\n        var constantLines = (this._options.constantLines || []).map(o => createConstantLine(this, o));\r\n        this._outsideConstantLines = constantLines.filter(l => \"outside\" === l.labelPosition);\r\n        this._insideConstantLines = constantLines.filter(l => \"inside\" === l.labelPosition)\r\n    },\r\n    draw: function(canvas, borderOptions) {\r\n        var that = this;\r\n        var options = this._options;\r\n        that.borderOptions = borderOptions || {\r\n            visible: false\r\n        };\r\n        that._resetMargins();\r\n        that.createTicks(canvas);\r\n        that.applyMargins();\r\n        that._clearAxisGroups();\r\n        initTickCoords(that._majorTicks);\r\n        initTickCoords(that._minorTicks);\r\n        initTickCoords(that._boundaryTicks);\r\n        that._axisGroup.append(that._axesContainerGroup);\r\n        that._drawAxis();\r\n        that._drawTitle();\r\n        drawTickMarks(that._majorTicks, options.tick);\r\n        drawTickMarks(that._minorTicks, options.minorTick);\r\n        drawTickMarks(that._boundaryTicks, options.tick);\r\n        var drawGridLine = that._getGridLineDrawer();\r\n        drawGrids(that._majorTicks, drawGridLine);\r\n        drawGrids(that._minorTicks, drawGridLine);\r\n        callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\r\n        that._templatesRendered && that._templatesRendered.reject();\r\n        that._templatesRendered = new Deferred;\r\n        that._majorTicks.forEach((function(tick) {\r\n            tick.labelRotationAngle = 0;\r\n            tick.labelAlignment = void 0;\r\n            tick.labelOffset = 0\r\n        }));\r\n        callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\r\n        callAction(that._strips, \"draw\");\r\n        that._dateMarkers = that._drawDateMarkers() || [];\r\n        that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\r\n        that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\r\n        that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\r\n        that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\r\n        if (that._constantLinesGroup) {\r\n            that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under)\r\n        }\r\n        that._measureTitle();\r\n        measureLabels(that._majorTicks);\r\n        !options.label.template && that._applyWordWrap();\r\n        measureLabels(that._outsideConstantLines);\r\n        measureLabels(that._insideConstantLines);\r\n        measureLabels(that._strips);\r\n        measureLabels(that._dateMarkers);\r\n        that._adjustConstantLineLabels(that._insideConstantLines);\r\n        that._adjustStripLabels();\r\n        var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\r\n        if (!that._translator.getBusinessRange().isEmpty()) {\r\n            that._setLabelsPlacement();\r\n            offset = that._adjustLabels(offset)\r\n        }\r\n        when.apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {\r\n            that._templatesRendered.resolve()\r\n        });\r\n        offset = that._adjustDateMarkers(offset);\r\n        that._adjustTitle(offset)\r\n    },\r\n    getTemplatesDef() {\r\n        return this._templatesRendered\r\n    },\r\n    setRenderedState(state) {\r\n        this._drawn = state\r\n    },\r\n    isRendered() {\r\n        return this._drawn\r\n    },\r\n    _applyWordWrap() {\r\n        var convertedTickInterval;\r\n        var textWidth;\r\n        var textHeight;\r\n        var options = this._options;\r\n        var tickInterval = this._tickInterval;\r\n        if (isDefined(tickInterval)) {\r\n            convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval)\r\n        }\r\n        var displayMode = this._validateDisplayMode(options.label.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\r\n        var wordWrapMode = options.label.wordWrap || \"none\";\r\n        var overflowMode = options.label.textOverflow || \"none\";\r\n        if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\r\n            var usefulSpace = isDefined(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\r\n            if (this._isHorizontal) {\r\n                textWidth = convertedTickInterval;\r\n                textHeight = usefulSpace\r\n            } else {\r\n                textWidth = usefulSpace;\r\n                textHeight = convertedTickInterval\r\n            }\r\n            var correctByWidth = false;\r\n            var correctByHeight = false;\r\n            if (textWidth) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {\r\n                    correctByWidth = true\r\n                }\r\n            }\r\n            if (textHeight) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {\r\n                    correctByHeight = true\r\n                }\r\n            }\r\n            if (correctByWidth || correctByHeight) {\r\n                this._majorTicks.forEach(tick => {\r\n                    tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label)\r\n                });\r\n                measureLabels(this._majorTicks)\r\n            }\r\n        }\r\n    },\r\n    _measureTitle: _noop,\r\n    animate() {\r\n        callAction(this._majorTicks, \"animateLabels\")\r\n    },\r\n    updateSize(canvas, animate) {\r\n        var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\r\n        this.updateCanvas(canvas);\r\n        if (updateTitle) {\r\n            this._checkTitleOverflow();\r\n            this._measureTitle();\r\n            this._updateTitleCoords()\r\n        }\r\n        this._reinitTranslator(this._getViewportRange());\r\n        this.applyMargins();\r\n        var animationEnabled = !this._firstDrawing && animate;\r\n        var options = this._options;\r\n        initTickCoords(this._majorTicks);\r\n        initTickCoords(this._minorTicks);\r\n        initTickCoords(this._boundaryTicks);\r\n        if (this._resetApplyingAnimation && !this._firstDrawing) {\r\n            this._resetStartCoordinates()\r\n        }\r\n        cleanUpInvalidTicks(this._majorTicks);\r\n        cleanUpInvalidTicks(this._minorTicks);\r\n        cleanUpInvalidTicks(this._boundaryTicks);\r\n        if (this._axisElement) {\r\n            this._updateAxisElementPosition()\r\n        }\r\n        updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\r\n        updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\r\n        updateTicksPosition(this._boundaryTicks, options.tick);\r\n        callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));\r\n        callAction(this._strips, \"updatePosition\", animationEnabled);\r\n        updateGridsPosition(this._majorTicks, animationEnabled);\r\n        updateGridsPosition(this._minorTicks, animationEnabled);\r\n        if (animationEnabled) {\r\n            callAction(this._ticksToRemove || [], \"fadeOutElements\")\r\n        }\r\n        this.prepareAnimation();\r\n        this._ticksToRemove = null;\r\n        if (!this._translator.getBusinessRange().isEmpty()) {\r\n            this._firstDrawing = false\r\n        }\r\n        this._resetApplyingAnimation = false;\r\n        this._updateLabelsPosition()\r\n    },\r\n    _updateLabelsPosition: _noop,\r\n    prepareAnimation() {\r\n        var action = \"saveCoords\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    _resetStartCoordinates() {\r\n        var action = \"resetCoordinates\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    applyClipRects: function(elementsClipID, canvasClipID) {\r\n        this._axisGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        });\r\n        this._axisStripGroup.attr({\r\n            \"clip-path\": elementsClipID\r\n        });\r\n        this._axisElementsGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        })\r\n    },\r\n    _validateVisualRange(optionValue) {\r\n        var range = getVizRangeObject(optionValue);\r\n        if (void 0 !== range.startValue) {\r\n            range.startValue = this.validateUnit(range.startValue)\r\n        }\r\n        if (void 0 !== range.endValue) {\r\n            range.endValue = this.validateUnit(range.endValue)\r\n        }\r\n        return convertVisualRangeObject(range, !_isArray(optionValue))\r\n    },\r\n    _validateOptions(options) {\r\n        options.wholeRange = this._validateVisualRange(options.wholeRange);\r\n        options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\r\n        this._setVisualRange(options._customVisualRange)\r\n    },\r\n    validate() {\r\n        var options = this._options;\r\n        var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\r\n        var parser = dataType ? getParser(dataType) : function(unit) {\r\n            return unit\r\n        };\r\n        this.parser = parser;\r\n        options.dataType = dataType;\r\n        this._validateOptions(options)\r\n    },\r\n    resetVisualRange(isSilent) {\r\n        this._seriesData.minVisible = this._seriesData.min;\r\n        this._seriesData.maxVisible = this._seriesData.max;\r\n        this.handleZooming([null, null], {\r\n            start: !!isSilent,\r\n            end: !!isSilent\r\n        })\r\n    },\r\n    _setVisualRange(visualRange, allowPartialUpdate) {\r\n        var range = this.adjustRange(getVizRangeObject(visualRange));\r\n        if (allowPartialUpdate) {\r\n            isDefined(range.startValue) && (this._viewport.startValue = range.startValue);\r\n            isDefined(range.endValue) && (this._viewport.endValue = range.endValue)\r\n        } else {\r\n            this._viewport = range\r\n        }\r\n    },\r\n    _applyZooming(visualRange, allowPartialUpdate) {\r\n        this._resetVisualRangeOption();\r\n        this._setVisualRange(visualRange, allowPartialUpdate);\r\n        var viewPort = this.getViewport();\r\n        this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\r\n            minVisible: viewPort.startValue,\r\n            maxVisible: viewPort.endValue\r\n        }, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    getZoomStartEventArg(event, actionType) {\r\n        return {\r\n            axis: this,\r\n            range: this.visualRange(),\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType\r\n        }\r\n    },\r\n    _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\r\n        var newRange = this.visualRange();\r\n        return {\r\n            axis: this,\r\n            previousRange: previousRange,\r\n            range: newRange,\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType,\r\n            zoomFactor: zoomFactor,\r\n            shift: shift,\r\n            rangeStart: newRange.startValue,\r\n            rangeEnd: newRange.endValue\r\n        }\r\n    },\r\n    getZoomBounds() {\r\n        var wholeRange = getVizRangeObject(this._options.wholeRange);\r\n        var range = this.getTranslator().getBusinessRange();\r\n        var secondPriorityRange = {\r\n            startValue: getZoomBoundValue(this._initRange.startValue, range.min),\r\n            endValue: getZoomBoundValue(this._initRange.endValue, range.max)\r\n        };\r\n        return {\r\n            startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\r\n            endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\r\n        }\r\n    },\r\n    setInitRange() {\r\n        this._initRange = {};\r\n        if (0 === Object.keys(this._options.wholeRange || {}).length) {\r\n            this._initRange = this.getZoomBounds()\r\n        }\r\n    },\r\n    _resetVisualRangeOption() {\r\n        this._options._customVisualRange = {}\r\n    },\r\n    getTemplatesGroups() {\r\n        var ticks = this._majorTicks;\r\n        if (ticks) {\r\n            return this._majorTicks.map(tick => tick.templateContainer).filter(item => isDefined(item))\r\n        } else {\r\n            return []\r\n        }\r\n    },\r\n    setCustomVisualRange(range) {\r\n        this._options._customVisualRange = range\r\n    },\r\n    visualRange() {\r\n        var args = arguments;\r\n        var visualRange;\r\n        if (0 === args.length) {\r\n            var adjustedRange = this._getAdjustedBusinessRange();\r\n            var startValue = adjustedRange.minVisible;\r\n            var endValue = adjustedRange.maxVisible;\r\n            if (this._options.type === constants.discrete) {\r\n                var _startValue, _endValue;\r\n                startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\r\n                endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\r\n                return {\r\n                    startValue: startValue,\r\n                    endValue: endValue,\r\n                    categories: getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\r\n                }\r\n            }\r\n            return {\r\n                startValue: startValue,\r\n                endValue: endValue\r\n            }\r\n        } else if (_isArray(args[0])) {\r\n            visualRange = args[0]\r\n        } else if (isPlainObject(args[0])) {\r\n            visualRange = extend({}, args[0])\r\n        } else {\r\n            visualRange = [args[0], args[1]]\r\n        }\r\n        var zoomResults = this.handleZooming(visualRange, args[1]);\r\n        if (!zoomResults.isPrevented) {\r\n            this._visualRange(this, zoomResults)\r\n        }\r\n    },\r\n    handleZooming(visualRange, preventEvents, domEvent, action) {\r\n        preventEvents = preventEvents || {};\r\n        if (isDefined(visualRange)) {\r\n            visualRange = this._validateVisualRange(visualRange);\r\n            visualRange.action = action\r\n        }\r\n        var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\r\n        var previousRange = zoomStartEvent.range;\r\n        !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\r\n        var zoomResults = {\r\n            isPrevented: zoomStartEvent.cancel,\r\n            skipEventRising: preventEvents.skipEventRising,\r\n            range: visualRange || zoomStartEvent.range\r\n        };\r\n        if (!zoomStartEvent.cancel) {\r\n            isDefined(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\r\n            if (!isDefined(this._storedZoomEndParams)) {\r\n                this._storedZoomEndParams = {\r\n                    startRange: previousRange,\r\n                    type: this.getOptions().type\r\n                }\r\n            }\r\n            this._storedZoomEndParams.event = domEvent;\r\n            this._storedZoomEndParams.action = action;\r\n            this._storedZoomEndParams.prevent = !!preventEvents.end\r\n        }\r\n        return zoomResults\r\n    },\r\n    handleZoomEnd() {\r\n        if (isDefined(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\r\n            var previousRange = this._storedZoomEndParams.startRange;\r\n            var domEvent = this._storedZoomEndParams.event;\r\n            var action = this._storedZoomEndParams.action;\r\n            var previousBusinessRange = {\r\n                minVisible: previousRange.startValue,\r\n                maxVisible: previousRange.endValue,\r\n                categories: previousRange.categories\r\n            };\r\n            var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\r\n            var shift = typeIsNotChanged ? adjust(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\r\n            var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\r\n            var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\r\n            zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\r\n            this._eventTrigger(\"zoomEnd\", zoomEndEvent);\r\n            if (zoomEndEvent.cancel) {\r\n                this._restorePreviousVisualRange(previousRange)\r\n            }\r\n            this._storedZoomEndParams = null\r\n        }\r\n    },\r\n    _restorePreviousVisualRange(previousRange) {\r\n        this._storedZoomEndParams = null;\r\n        this._applyZooming(previousRange);\r\n        this._visualRange(this, previousRange)\r\n    },\r\n    checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\r\n        var options = this._options;\r\n        var translator = this._translator;\r\n        var minZoom = options.minVisualRangeLength;\r\n        var correctedRange = range;\r\n        var visualRange;\r\n        var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\r\n        var businessRange = translator.getBusinessRange();\r\n        if (range) {\r\n            visualRange = this.adjustRange(getVizRangeObject(range));\r\n            visualRange = {\r\n                minVisible: visualRange.startValue,\r\n                maxVisible: visualRange.endValue,\r\n                categories: businessRange.categories\r\n            }\r\n        }\r\n        var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\r\n        var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\r\n        if (isDefined(minZoom) || \"discrete\" === options.type) {\r\n            minZoom = translator.convert(minZoom);\r\n            if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\r\n                correctedRange = getVizRangeObject(translator.getRangeByMinZoomValue(minZoom, visualRange));\r\n                isOvercoming = false\r\n            } else {\r\n                isOvercoming &= minZoom > afterVisualRangeLength\r\n            }\r\n        } else {\r\n            var canvasLength = this._translator.canvasLength;\r\n            var fullRange = {\r\n                minVisible: businessRange.min,\r\n                maxVisible: businessRange.max,\r\n                categories: businessRange.categories\r\n            };\r\n            isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength\r\n        }\r\n        return {\r\n            stopInteraction: !!isOvercoming,\r\n            correctedRange: correctedRange\r\n        }\r\n    },\r\n    isExtremePosition(isMax) {\r\n        var extremeDataValue;\r\n        var seriesData;\r\n        if (\"discrete\" === this._options.type) {\r\n            seriesData = this._translator.getBusinessRange();\r\n            extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0]\r\n        } else {\r\n            seriesData = this.getZoomBounds();\r\n            extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue\r\n        }\r\n        var translator = this.getTranslator();\r\n        var extremePoint = translator.translate(extremeDataValue);\r\n        var visualRange = this.visualRange();\r\n        var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\r\n        return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD\r\n    },\r\n    getViewport() {\r\n        return this._viewport\r\n    },\r\n    getFullTicks: function() {\r\n        var majors = this._majorTicks || [];\r\n        if (this._options.type === constants.discrete) {\r\n            return convertTicksToValues(majors)\r\n        } else {\r\n            return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort((function(a, b) {\r\n                return valueOf(a) - valueOf(b)\r\n            }))\r\n        }\r\n    },\r\n    measureLabels: function(canvas, withIndents) {\r\n        var that = this;\r\n        var options = that._options;\r\n        var widthAxis = options.visible ? options.width : 0;\r\n        var ticks;\r\n        var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\r\n        var tickInterval;\r\n        var viewportRange = that._getViewportRange();\r\n        if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\r\n            return {\r\n                height: widthAxis,\r\n                width: widthAxis,\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        }\r\n        if (that._majorTicks) {\r\n            ticks = convertTicksToValues(that._majorTicks)\r\n        } else {\r\n            that.updateCanvas(canvas);\r\n            ticks = that._createTicksAndLabelFormat(viewportRange, _noop);\r\n            tickInterval = ticks.tickInterval;\r\n            ticks = ticks.ticks\r\n        }\r\n        var maxText = ticks.reduce((function(prevLabel, tick, index) {\r\n            var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\r\n            if (prevLabel.length < label.length) {\r\n                return label\r\n            } else {\r\n                return prevLabel\r\n            }\r\n        }), that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\r\n        var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\r\n        var box = text.getBBox();\r\n        text.remove();\r\n        return {\r\n            x: box.x,\r\n            y: box.y,\r\n            width: box.width + indent,\r\n            height: box.height + indent\r\n        }\r\n    },\r\n    _setLabelsPlacement: function() {\r\n        if (!this._options.label.visible) {\r\n            return\r\n        }\r\n        var labelOpt = this._options.label;\r\n        var displayMode = this._validateDisplayMode(labelOpt.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\r\n        var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\r\n        var behavior = {\r\n            rotationAngle: labelOpt.rotationAngle,\r\n            staggeringSpacing: labelOpt.staggeringSpacing\r\n        };\r\n        var notRecastStep;\r\n        var boxes = this._majorTicks.map((function(tick) {\r\n            return tick.labelBBox\r\n        }));\r\n        var step = this._getStep(boxes);\r\n        switch (displayMode) {\r\n            case ROTATE:\r\n                if (ignoreOverlapping) {\r\n                    notRecastStep = true;\r\n                    step = 1\r\n                }\r\n                this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\r\n                break;\r\n            case \"stagger\":\r\n                if (ignoreOverlapping) {\r\n                    step = 2\r\n                }\r\n                this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\r\n                break;\r\n            default:\r\n                this._applyLabelOverlapping(boxes, overlappingMode, step, behavior)\r\n        }\r\n    },\r\n    _applyLabelOverlapping: function(boxes, mode, step, behavior) {\r\n        var labelOpt = this._options.label;\r\n        var majorTicks = this._majorTicks;\r\n        if (\"none\" === mode || \"ignore\" === mode) {\r\n            return\r\n        }\r\n        if (step > 1 && boxes.some((function(box, index, array) {\r\n                if (0 === index) {\r\n                    return false\r\n                }\r\n                return constants.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment)\r\n            }))) {\r\n            this._applyLabelMode(mode, step, boxes, behavior)\r\n        }\r\n        this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\r\n        this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment)\r\n    },\r\n    _applyLabelMode: function(mode, step, boxes, behavior, notRecastStep) {\r\n        var majorTicks = this._majorTicks;\r\n        var labelOpt = this._options.label;\r\n        var angle = behavior.rotationAngle;\r\n        var labelHeight;\r\n        var alignment;\r\n        var func;\r\n        switch (mode) {\r\n            case ROTATE:\r\n                if (!labelOpt.userAlignment) {\r\n                    alignment = angle < 0 ? RIGHT : LEFT;\r\n                    if (angle % 90 === 0) {\r\n                        alignment = CENTER\r\n                    }\r\n                }\r\n                step = notRecastStep ? step : this._getStep(boxes, angle);\r\n                func = function(tick) {\r\n                    var contentContainer = tick.getContentContainer();\r\n                    if (!contentContainer) {\r\n                        return\r\n                    }\r\n                    contentContainer.rotate(angle);\r\n                    tick.labelRotationAngle = angle;\r\n                    alignment && (tick.labelAlignment = alignment)\r\n                };\r\n                updateLabels(majorTicks, step, func);\r\n                break;\r\n            case \"stagger\":\r\n                labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\r\n                func = function(tick, index) {\r\n                    if (index / (step - 1) % 2 !== 0) {\r\n                        tick.labelOffset = labelHeight\r\n                    }\r\n                };\r\n                updateLabels(majorTicks, step - 1, func);\r\n                break;\r\n            case \"auto\":\r\n            case \"_auto\":\r\n                if (2 === step) {\r\n                    this._applyLabelMode(\"stagger\", step, boxes, behavior)\r\n                } else {\r\n                    this._applyLabelMode(ROTATE, step, boxes, {\r\n                        rotationAngle: getOptimalAngle(boxes, labelOpt)\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                updateLabels(majorTicks, step)\r\n        }\r\n    },\r\n    getMarkerTrackers: _noop,\r\n    _drawDateMarkers: _noop,\r\n    _adjustDateMarkers: _noop,\r\n    coordsIn: _noop,\r\n    areCoordsOutsideAxis: _noop,\r\n    _getSkippedCategory: _noop,\r\n    _initAxisPositions: _noop,\r\n    _drawTitle: _noop,\r\n    _updateTitleCoords: _noop,\r\n    _adjustConstantLineLabels: _noop,\r\n    _createTranslator: function() {\r\n        return new Translator2D({}, {}, {})\r\n    },\r\n    _updateTranslator: function() {\r\n        var translator = this._translator;\r\n        translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions())\r\n    },\r\n    _getTranslatorOptions: function() {\r\n        var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\r\n        var options = this._options;\r\n        return {\r\n            isHorizontal: this._isHorizontal,\r\n            shiftZeroValue: !this.isArgumentAxis,\r\n            interval: options.semiDiscreteInterval,\r\n            firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\r\n            stick: this._getStick(),\r\n            breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\r\n        }\r\n    },\r\n    getVisibleArea() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        return [canvas.start, canvas.end].sort((a, b) => a - b)\r\n    },\r\n    _getCanvasStartEnd: function() {\r\n        var isHorizontal = this._isHorizontal;\r\n        var canvas = this._canvas || {};\r\n        var invert = this._translator.getBusinessRange().invert;\r\n        var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\r\n        invert && coords.reverse();\r\n        return {\r\n            start: coords[0],\r\n            end: coords[1]\r\n        }\r\n    },\r\n    _getScreenDelta: function() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\r\n        var breaksLength = breaks.length;\r\n        var screenDelta = _abs(canvas.start - canvas.end);\r\n        return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0)\r\n    },\r\n    _getScaleBreaks: function() {\r\n        return []\r\n    },\r\n    _filterBreaks: function() {\r\n        return []\r\n    },\r\n    _adjustTitle: _noop,\r\n    _checkTitleOverflow: _noop,\r\n    getSpiderTicks: _noop,\r\n    setSpiderTicks: _noop,\r\n    _checkBoundedLabelsOverlapping: _noop,\r\n    _checkShiftedLabels: _noop,\r\n    drawScaleBreaks: _noop,\r\n    _visualRange: _noop,\r\n    _rotateConstantLine: _noop,\r\n    applyVisualRangeSetter(visualRangeSetter) {\r\n        this._visualRange = visualRangeSetter\r\n    },\r\n    getCategoriesSorter(argCategories) {\r\n        var sort;\r\n        if (this.isArgumentAxis) {\r\n            sort = argCategories\r\n        } else {\r\n            var categoriesSortingMethod = this._options.categoriesSortingMethod;\r\n            sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories\r\n        }\r\n        return sort\r\n    },\r\n    _getAdjustedBusinessRange() {\r\n        return this.adjustViewport(this._translator.getBusinessRange())\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}