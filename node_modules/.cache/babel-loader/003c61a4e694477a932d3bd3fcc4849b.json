{"ast":null,"code":"/**\n* DevExpress Analytics (core\\snapLines\\_snapLinesHelper.js)\n* Version:  22.1.3\n* Build date: Jun 14, 2022\n* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\n* License: https://www.devexpress.com/Support/EULAs/universal.xml\n*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SnapLinesHelper = void 0;\n\nvar _snapLinesCollector_1 = require(\"./_snapLinesCollector\");\n\nvar _snapLineSurface_1 = require(\"./_snapLineSurface\");\n\nvar _arrayutils_1 = require(\"../utils/_arrayutils\");\n\nvar SnapLinesHelper = function () {\n  function SnapLinesHelper(surface, snapTolerance, snapLinesCollector) {\n    if (surface === void 0) {\n      surface = null;\n    }\n\n    if (snapTolerance === void 0) {\n      snapTolerance = SnapLinesHelper.snapTolerance;\n    }\n\n    if (snapLinesCollector === void 0) {\n      snapLinesCollector = new _snapLinesCollector_1.SnapLinesCollector();\n    }\n\n    this.snapLineSurfaces = [new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface()];\n    this.verticalSnapLines = [];\n    this.horizontalSnapLines = [];\n    this._surfaceContext = surface;\n    this._snapTolerance = snapTolerance;\n    this._snapLinesCollector = snapLinesCollector;\n  }\n\n  SnapLinesHelper.prototype._findClosestSnapLine = function (position, snapLines) {\n    var line = {\n      position: position,\n      limitInf: 0,\n      limSup: 0\n    };\n\n    var index = _arrayutils_1.binaryIndexOf(snapLines, line, function (a, b) {\n      return a.position - b.position;\n    });\n\n    var snapLineCandidate;\n\n    if (index > -1) {\n      snapLineCandidate = {\n        snapLine: snapLines[index],\n        distance: position - snapLines[index].position\n      };\n    } else {\n      index = ~index;\n      var delta1 = snapLines[index] ? position - snapLines[index].position : Number.MAX_VALUE;\n      var delta2 = snapLines[index - 1] ? position - snapLines[index - 1].position : Number.MAX_VALUE;\n      snapLineCandidate = Math.abs(delta1) > Math.abs(delta2) ? {\n        snapLine: snapLines[index - 1],\n        distance: delta2\n      } : {\n        snapLine: snapLines[index],\n        distance: delta1\n      };\n    }\n\n    return snapLineCandidate;\n  };\n\n  SnapLinesHelper.prototype._getActiveSnapLines = function (position1, position2, snapLines) {\n    var line1 = this._findClosestSnapLine(position1, snapLines);\n\n    var line2 = this._findClosestSnapLine(position2, snapLines);\n\n    var result = {\n      lines: [],\n      distance: 0\n    };\n\n    if (Math.abs(line1.distance - line2.distance) >= 1) {\n      var line = Math.abs(line1.distance) < Math.abs(line2.distance) ? line1 : line2;\n\n      if (Math.abs(line.distance) <= this._snapTolerance) {\n        result.lines = [line];\n        result.distance = line.distance;\n      }\n    } else if (Math.abs(line1.distance) <= this._snapTolerance) {\n      result.lines = [line1, line2];\n      result.distance = line1.distance;\n    }\n\n    return result;\n  };\n\n  SnapLinesHelper.prototype.updateSnapLines = function (snapTargetToIgnore) {\n    if (snapTargetToIgnore === void 0) {\n      snapTargetToIgnore = null;\n    }\n\n    this.verticalSnapLines.splice(0);\n    this.horizontalSnapLines.splice(0);\n\n    var result = this._snapLinesCollector.collectSnaplines(this._surfaceContext(), snapTargetToIgnore);\n\n    this.verticalSnapLines.push.apply(this.verticalSnapLines, result.vertical);\n    this.horizontalSnapLines.push.apply(this.horizontalSnapLines, result.horizontal);\n  };\n\n  SnapLinesHelper.prototype.deactivateSnapLines = function () {\n    this.snapLineSurfaces[0].reset();\n    this.snapLineSurfaces[1].reset();\n    this.snapLineSurfaces[2].reset();\n    this.snapLineSurfaces[3].reset();\n  };\n\n  SnapLinesHelper.prototype.activateSnapLines = function (position) {\n    var vertical = this._getActiveSnapLines(position.left, position.right, this.verticalSnapLines);\n\n    var horizontal = this._getActiveSnapLines(position.top, position.bottom, this.horizontalSnapLines);\n\n    for (var i = 0; i < 2; i++) {\n      var line = vertical.lines[i];\n\n      if (!line) {\n        this.snapLineSurfaces[i].reset();\n      } else {\n        var top = Math.min(line.snapLine.limitInf, position.top);\n        var bottom = Math.max(line.snapLine.limSup, position.bottom);\n\n        if (position.top < line.snapLine.limitInf) {\n          top -= horizontal.distance;\n        }\n\n        if (position.bottom > line.snapLine.limSup) {\n          bottom -= horizontal.distance;\n        }\n\n        this.snapLineSurfaces[i].updatePosition({\n          top: top,\n          left: line.snapLine.position,\n          height: bottom - top,\n          width: 1\n        });\n      }\n    }\n\n    for (var i = 0; i < 2; i++) {\n      var line = horizontal.lines[i];\n\n      if (!line) {\n        this.snapLineSurfaces[i + 2].reset();\n      } else {\n        var left = Math.min(line.snapLine.limitInf, position.left);\n        var right = Math.max(line.snapLine.limSup, position.right);\n\n        if (position.left < line.snapLine.limitInf) {\n          left -= vertical.distance;\n        }\n\n        if (position.right > line.snapLine.limSup) {\n          right -= vertical.distance;\n        }\n\n        this.snapLineSurfaces[i + 2].updatePosition({\n          top: line.snapLine.position,\n          left: left,\n          width: right - left,\n          height: 1\n        });\n      }\n    }\n\n    return {\n      left: vertical.distance,\n      top: horizontal.distance\n    };\n  };\n\n  SnapLinesHelper.prototype.snapPosition = function (position, horizontal) {\n    var line = this._findClosestSnapLine(position, horizontal ? this.horizontalSnapLines : this.verticalSnapLines);\n\n    return line && Math.abs(line.distance) <= this._snapTolerance ? line.snapLine.position : position;\n  };\n\n  SnapLinesHelper.snapTolerance = 10;\n  return SnapLinesHelper;\n}();\n\nexports.SnapLinesHelper = SnapLinesHelper;","map":{"version":3,"sources":["/Users/kevinrabari/Desktop/Georgian College Work/1005_ Mobile Web Application/Assignment3/node_modules/@devexpress/analytics-core/core/snapLines/_snapLinesHelper.js"],"names":["Object","defineProperty","exports","value","SnapLinesHelper","_snapLinesCollector_1","require","_snapLineSurface_1","_arrayutils_1","surface","snapTolerance","snapLinesCollector","SnapLinesCollector","snapLineSurfaces","SnapLineSurface","verticalSnapLines","horizontalSnapLines","_surfaceContext","_snapTolerance","_snapLinesCollector","prototype","_findClosestSnapLine","position","snapLines","line","limitInf","limSup","index","binaryIndexOf","a","b","snapLineCandidate","snapLine","distance","delta1","Number","MAX_VALUE","delta2","Math","abs","_getActiveSnapLines","position1","position2","line1","line2","result","lines","updateSnapLines","snapTargetToIgnore","splice","collectSnaplines","push","apply","vertical","horizontal","deactivateSnapLines","reset","activateSnapLines","left","right","top","bottom","i","min","max","updatePosition","height","width","snapPosition"],"mappings":"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","sourcesContent":["/**\n* DevExpress Analytics (core\\snapLines\\_snapLinesHelper.js)\n* Version:  22.1.3\n* Build date: Jun 14, 2022\n* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\n* License: https://www.devexpress.com/Support/EULAs/universal.xml\n*/\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SnapLinesHelper = void 0;\nvar _snapLinesCollector_1 = require(\"./_snapLinesCollector\");\nvar _snapLineSurface_1 = require(\"./_snapLineSurface\");\nvar _arrayutils_1 = require(\"../utils/_arrayutils\");\nvar SnapLinesHelper = (function () {\n    function SnapLinesHelper(surface, snapTolerance, snapLinesCollector) {\n        if (surface === void 0) { surface = null; }\n        if (snapTolerance === void 0) { snapTolerance = SnapLinesHelper.snapTolerance; }\n        if (snapLinesCollector === void 0) { snapLinesCollector = new _snapLinesCollector_1.SnapLinesCollector(); }\n        this.snapLineSurfaces = [new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface(), new _snapLineSurface_1.SnapLineSurface()];\n        this.verticalSnapLines = [];\n        this.horizontalSnapLines = [];\n        this._surfaceContext = surface;\n        this._snapTolerance = snapTolerance;\n        this._snapLinesCollector = snapLinesCollector;\n    }\n    SnapLinesHelper.prototype._findClosestSnapLine = function (position, snapLines) {\n        var line = {\n            position: position,\n            limitInf: 0,\n            limSup: 0\n        };\n        var index = _arrayutils_1.binaryIndexOf(snapLines, line, function (a, b) { return a.position - b.position; });\n        var snapLineCandidate;\n        if (index > -1) {\n            snapLineCandidate = {\n                snapLine: snapLines[index],\n                distance: position - snapLines[index].position\n            };\n        }\n        else {\n            index = ~index;\n            var delta1 = snapLines[index] ? (position - snapLines[index].position) : Number.MAX_VALUE;\n            var delta2 = snapLines[index - 1] ? (position - snapLines[index - 1].position) : Number.MAX_VALUE;\n            snapLineCandidate = Math.abs(delta1) > Math.abs(delta2) ?\n                { snapLine: snapLines[index - 1], distance: delta2 } :\n                { snapLine: snapLines[index], distance: delta1 };\n        }\n        return snapLineCandidate;\n    };\n    SnapLinesHelper.prototype._getActiveSnapLines = function (position1, position2, snapLines) {\n        var line1 = this._findClosestSnapLine(position1, snapLines);\n        var line2 = this._findClosestSnapLine(position2, snapLines);\n        var result = {\n            lines: [],\n            distance: 0\n        };\n        if (Math.abs(line1.distance - line2.distance) >= 1) {\n            var line = Math.abs(line1.distance) < Math.abs(line2.distance) ? line1 : line2;\n            if (Math.abs(line.distance) <= this._snapTolerance) {\n                result.lines = [line];\n                result.distance = line.distance;\n            }\n        }\n        else if (Math.abs(line1.distance) <= this._snapTolerance) {\n            result.lines = [line1, line2];\n            result.distance = line1.distance;\n        }\n        return result;\n    };\n    SnapLinesHelper.prototype.updateSnapLines = function (snapTargetToIgnore) {\n        if (snapTargetToIgnore === void 0) { snapTargetToIgnore = null; }\n        this.verticalSnapLines.splice(0);\n        this.horizontalSnapLines.splice(0);\n        var result = this._snapLinesCollector.collectSnaplines(this._surfaceContext(), snapTargetToIgnore);\n        this.verticalSnapLines.push.apply(this.verticalSnapLines, result.vertical);\n        this.horizontalSnapLines.push.apply(this.horizontalSnapLines, result.horizontal);\n    };\n    SnapLinesHelper.prototype.deactivateSnapLines = function () {\n        this.snapLineSurfaces[0].reset();\n        this.snapLineSurfaces[1].reset();\n        this.snapLineSurfaces[2].reset();\n        this.snapLineSurfaces[3].reset();\n    };\n    SnapLinesHelper.prototype.activateSnapLines = function (position) {\n        var vertical = this._getActiveSnapLines(position.left, position.right, this.verticalSnapLines);\n        var horizontal = this._getActiveSnapLines(position.top, position.bottom, this.horizontalSnapLines);\n        for (var i = 0; i < 2; i++) {\n            var line = vertical.lines[i];\n            if (!line) {\n                this.snapLineSurfaces[i].reset();\n            }\n            else {\n                var top = Math.min(line.snapLine.limitInf, position.top);\n                var bottom = Math.max(line.snapLine.limSup, position.bottom);\n                if (position.top < line.snapLine.limitInf) {\n                    top -= horizontal.distance;\n                }\n                if (position.bottom > line.snapLine.limSup) {\n                    bottom -= horizontal.distance;\n                }\n                this.snapLineSurfaces[i].updatePosition({\n                    top: top,\n                    left: line.snapLine.position,\n                    height: bottom - top,\n                    width: 1\n                });\n            }\n        }\n        for (var i = 0; i < 2; i++) {\n            var line = horizontal.lines[i];\n            if (!line) {\n                this.snapLineSurfaces[i + 2].reset();\n            }\n            else {\n                var left = Math.min(line.snapLine.limitInf, position.left);\n                var right = Math.max(line.snapLine.limSup, position.right);\n                if (position.left < line.snapLine.limitInf) {\n                    left -= vertical.distance;\n                }\n                if (position.right > line.snapLine.limSup) {\n                    right -= vertical.distance;\n                }\n                this.snapLineSurfaces[i + 2].updatePosition({\n                    top: line.snapLine.position,\n                    left: left,\n                    width: right - left,\n                    height: 1\n                });\n            }\n        }\n        return {\n            left: vertical.distance,\n            top: horizontal.distance\n        };\n    };\n    SnapLinesHelper.prototype.snapPosition = function (position, horizontal) {\n        var line = this._findClosestSnapLine(position, horizontal ? this.horizontalSnapLines : this.verticalSnapLines);\n        return (line && Math.abs(line.distance) <= this._snapTolerance) ? line.snapLine.position : position;\n    };\n    SnapLinesHelper.snapTolerance = 10;\n    return SnapLinesHelper;\n}());\nexports.SnapLinesHelper = SnapLinesHelper;\n"]},"metadata":{},"sourceType":"script"}