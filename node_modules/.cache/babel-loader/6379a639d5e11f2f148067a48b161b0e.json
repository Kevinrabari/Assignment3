{"ast":null,"code":"/**\r\n* DevExpress Dashboard (_gauge-range-calculator.js)\r\n* Version:  22.1.3\r\n* Build date: Jun 13, 2022\r\n* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n* License: https://www.devexpress.com/Support/EULAs/universal.xml\r\n*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gaugeRangeCalculator = void 0;\n\nvar _utils_1 = require(\"./_utils\");\n\nvar gaugeRangeCalculator = function () {\n  function gaugeRangeCalculator(options) {\n    this._values = options.values;\n    this._gaugeViewType = options.gaugeModel.Type;\n    this._customMin = options.gaugeModel.MinValue;\n    this._customMax = options.gaugeModel.MaxValue;\n    this._minDefined = this._customMin != null;\n    this._maxDefined = this._customMax != null;\n\n    this._defineMinMaxTicks();\n  }\n\n  gaugeRangeCalculator.prototype.getGaugeRange = function () {\n    this._defineMinMax();\n\n    this._setRangeStart();\n\n    this._extendRange();\n\n    var left = Math.min(this._min, this._max),\n        right = Math.max(this._min, this._max),\n        rangeLength = right - left,\n        scaleReversed = this._min > this._max,\n        majorTickCount,\n        minorTickCount,\n        stepCount,\n        step,\n        delta,\n        fit,\n        currentStep,\n        currentDelta,\n        currentFit;\n\n    if (rangeLength === 0) {\n      majorTickCount = 1;\n      minorTickCount = 0;\n    } else {\n      stepCount = this._minTickCount - 1;\n      step = this._chooseMultiplier(rangeLength / stepCount);\n      delta = step * stepCount - rangeLength;\n      fit = this._isFit(left, right, step, stepCount);\n\n      for (var i = stepCount + 1; i < this._maxTickCount; i++) {\n        currentStep = this._chooseMultiplier(rangeLength / i);\n        currentDelta = currentStep * i - rangeLength;\n        currentFit = this._isFit(left, right, currentStep, i);\n\n        if (currentFit && (currentDelta < delta || !fit)) {\n          delta = currentDelta;\n          step = currentStep;\n          fit = currentFit;\n          stepCount = i;\n        }\n      }\n\n      left = this._getLeft(left, step);\n      right = this._getRight(right, step);\n      this._min = !scaleReversed ? left : right;\n      this._max = !scaleReversed ? right : left;\n      majorTickCount = stepCount + 1;\n      if (step % 5 === 0) minorTickCount = 4;else if (step % 3 === 0) minorTickCount = 2;else minorTickCount = 3;\n      return {\n        minorTickCount: minorTickCount,\n        majorTickCount: majorTickCount,\n        min: this._min,\n        max: this._max\n      };\n    }\n  };\n\n  gaugeRangeCalculator.prototype._getLeft = function (left, step) {\n    var sign = left > 0 ? 1 : -1;\n    if (this._equalSign && left > 0) return Math.floor(Math.abs(left) / step) * step * sign;else return Math.ceil(Math.abs(left) / step) * step * sign;\n  };\n\n  gaugeRangeCalculator.prototype._getRight = function (right, step) {\n    var sign = right > 0 ? 1 : -1;\n    if (this._equalSign && right < 0) return Math.floor(Math.abs(right) / step) * step * sign;else return Math.ceil(Math.abs(right) / step) * step * sign;\n  };\n\n  gaugeRangeCalculator.prototype._isFit = function (left, right, step, tickCount) {\n    var leftAbs = Math.abs(left),\n        rigthAbs = Math.abs(right),\n        isFit = false;\n\n    if (!this._signsEqual(left, right)) {\n      isFit = Math.ceil(leftAbs / step) + Math.ceil(rigthAbs / step) <= tickCount;\n    } else {\n      var minAbs = Math.min(leftAbs, rigthAbs),\n          maxAbs = Math.max(leftAbs, rigthAbs);\n      isFit = Math.ceil(maxAbs / step) - Math.floor(minAbs / step) <= tickCount;\n    }\n\n    return isFit;\n  };\n\n  gaugeRangeCalculator.prototype._extendRange = function () {\n    var that = this,\n        extendMin = function (coef) {\n      if (!that._minDefined) that._min *= coef;\n    },\n        extendMax = function (coef) {\n      if (!that._maxDefined) that._max *= coef;\n    };\n\n    if (this._equalSign) {\n      if (Math.abs(this._min) < Math.abs(this._max)) {\n        extendMin(0.95);\n        extendMax(1.05);\n      } else {\n        extendMin(1.05);\n        extendMax(0.95);\n      }\n    } else {\n      extendMin(1.05);\n      extendMax(1.05);\n    }\n\n    if (this._min === this._max) {\n      if (this._min !== 0) this._max *= 1.4;else this._max = 1;\n    }\n  };\n\n  gaugeRangeCalculator.prototype._setRangeStart = function () {\n    if (this._equalSign) {\n      if (this._min === this._max) {\n        if (this._min > 0) {\n          if (!this._minDefined) this._min = 0;\n        } else {\n          if (!this._maxDefined) this._max = 0;\n        }\n      }\n\n      if (Math.abs(this._min) <= Math.abs(this._max)) {\n        if (!this._minDefined) this._min = 0;\n      } else {\n        if (!this._maxDefined) this._max = 0;\n      }\n    }\n  };\n\n  gaugeRangeCalculator.prototype._defineMinMax = function () {\n    if (this._minDefined) this._min = this._customMin;else this._min = this._values.length > 0 ? Math.min.apply(Math, this._values) : 0;\n    if (this._maxDefined) this._max = this._customMax;else this._max = this._values.length > 0 ? Math.max.apply(Math, this._values) : 1;\n    this._equalSign = this._signsEqual(this._min, this._max);\n  };\n\n  gaugeRangeCalculator.prototype._signsEqual = function (number1, number2) {\n    return number1 >= 0 && number2 >= 0 || number1 < 0 && number2 < 0;\n  };\n\n  gaugeRangeCalculator.prototype._defineMinMaxTicks = function () {\n    switch (this._gaugeViewType) {\n      case _utils_1.gaugeViewType.CircularFull:\n        this._minTickCount = 6;\n        this._maxTickCount = 9;\n        break;\n\n      case _utils_1.gaugeViewType.LinearHorizontal:\n        this._minTickCount = 3;\n        this._maxTickCount = 3;\n        break;\n\n      default:\n        this._minTickCount = 4;\n        this._maxTickCount = 6;\n        break;\n    }\n  };\n\n  gaugeRangeCalculator.prototype._chooseMultiplier = function (delta) {\n    var multipliers = [1, 2, 3, 5],\n        result,\n        exp,\n        scale,\n        normDelta,\n        newResult,\n        i;\n\n    if (delta > 1) {\n      for (var factor = 1;; factor *= 10) {\n        for (i = 0; i < multipliers.length; i++) {\n          result = multipliers[i] * factor;\n          if (delta <= result) return result;\n        }\n      }\n    } else {\n      result = 10;\n      exp = Math.floor(Math.log(Math.abs(delta)) / Math.LN10);\n      scale = Math.pow(10, -exp);\n      normDelta = delta * scale;\n\n      for (i = multipliers.length - 1; i >= 0; i--) {\n        newResult = multipliers[i];\n\n        if (normDelta > newResult) {\n          break;\n        }\n\n        result = newResult;\n      }\n\n      return result / scale;\n    }\n  };\n\n  return gaugeRangeCalculator;\n}();\n\nexports.gaugeRangeCalculator = gaugeRangeCalculator;","map":{"version":3,"sources":["/Users/krunalpatel/Downloads/React-Firebase-Auth-master 3/node_modules/devexpress-dashboard/data/_gauge-range-calculator.js"],"names":["Object","defineProperty","exports","value","gaugeRangeCalculator","_utils_1","require","options","_values","values","_gaugeViewType","gaugeModel","Type","_customMin","MinValue","_customMax","MaxValue","_minDefined","_maxDefined","_defineMinMaxTicks","prototype","getGaugeRange","_defineMinMax","_setRangeStart","_extendRange","left","Math","min","_min","_max","right","max","rangeLength","scaleReversed","majorTickCount","minorTickCount","stepCount","step","delta","fit","currentStep","currentDelta","currentFit","_minTickCount","_chooseMultiplier","_isFit","i","_maxTickCount","_getLeft","_getRight","sign","_equalSign","floor","abs","ceil","tickCount","leftAbs","rigthAbs","isFit","_signsEqual","minAbs","maxAbs","that","extendMin","coef","extendMax","length","apply","number1","number2","gaugeViewType","CircularFull","LinearHorizontal","multipliers","result","exp","scale","normDelta","newResult","factor","log","LN10","pow"],"mappings":"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","sourcesContent":["/**\r\n* DevExpress Dashboard (_gauge-range-calculator.js)\r\n* Version:  22.1.3\r\n* Build date: Jun 13, 2022\r\n* Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n* License: https://www.devexpress.com/Support/EULAs/universal.xml\r\n*/\r\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gaugeRangeCalculator = void 0;\nvar _utils_1 = require(\"./_utils\");\nvar gaugeRangeCalculator = (function () {\n    function gaugeRangeCalculator(options) {\n        this._values = options.values;\n        this._gaugeViewType = options.gaugeModel.Type;\n        this._customMin = options.gaugeModel.MinValue;\n        this._customMax = options.gaugeModel.MaxValue;\n        this._minDefined = this._customMin != null;\n        this._maxDefined = this._customMax != null;\n        this._defineMinMaxTicks();\n    }\n    gaugeRangeCalculator.prototype.getGaugeRange = function () {\n        this._defineMinMax();\n        this._setRangeStart();\n        this._extendRange();\n        var left = Math.min(this._min, this._max), right = Math.max(this._min, this._max), rangeLength = right - left, scaleReversed = this._min > this._max, majorTickCount, minorTickCount, stepCount, step, delta, fit, currentStep, currentDelta, currentFit;\n        if (rangeLength === 0) {\n            majorTickCount = 1;\n            minorTickCount = 0;\n        }\n        else {\n            stepCount = this._minTickCount - 1;\n            step = this._chooseMultiplier(rangeLength / stepCount);\n            delta = step * stepCount - rangeLength;\n            fit = this._isFit(left, right, step, stepCount);\n            for (var i = stepCount + 1; i < this._maxTickCount; i++) {\n                currentStep = this._chooseMultiplier(rangeLength / i);\n                currentDelta = currentStep * i - rangeLength;\n                currentFit = this._isFit(left, right, currentStep, i);\n                if (currentFit && (currentDelta < delta || !fit)) {\n                    delta = currentDelta;\n                    step = currentStep;\n                    fit = currentFit;\n                    stepCount = i;\n                }\n            }\n            left = this._getLeft(left, step);\n            right = this._getRight(right, step);\n            this._min = !scaleReversed ? left : right;\n            this._max = !scaleReversed ? right : left;\n            majorTickCount = stepCount + 1;\n            if (step % 5 === 0)\n                minorTickCount = 4;\n            else if (step % 3 === 0)\n                minorTickCount = 2;\n            else\n                minorTickCount = 3;\n            return {\n                minorTickCount: minorTickCount,\n                majorTickCount: majorTickCount,\n                min: this._min,\n                max: this._max\n            };\n        }\n    };\n    gaugeRangeCalculator.prototype._getLeft = function (left, step) {\n        var sign = left > 0 ? 1 : -1;\n        if (this._equalSign && left > 0)\n            return Math.floor(Math.abs(left) / step) * step * sign;\n        else\n            return Math.ceil(Math.abs(left) / step) * step * sign;\n    };\n    gaugeRangeCalculator.prototype._getRight = function (right, step) {\n        var sign = right > 0 ? 1 : -1;\n        if (this._equalSign && right < 0)\n            return Math.floor(Math.abs(right) / step) * step * sign;\n        else\n            return Math.ceil(Math.abs(right) / step) * step * sign;\n    };\n    gaugeRangeCalculator.prototype._isFit = function (left, right, step, tickCount) {\n        var leftAbs = Math.abs(left), rigthAbs = Math.abs(right), isFit = false;\n        if (!this._signsEqual(left, right)) {\n            isFit = (Math.ceil(leftAbs / step) + Math.ceil(rigthAbs / step)) <= tickCount;\n        }\n        else {\n            var minAbs = Math.min(leftAbs, rigthAbs), maxAbs = Math.max(leftAbs, rigthAbs);\n            isFit = Math.ceil(maxAbs / step) - Math.floor(minAbs / step) <= tickCount;\n        }\n        return isFit;\n    };\n    gaugeRangeCalculator.prototype._extendRange = function () {\n        var that = this, extendMin = function (coef) {\n            if (!that._minDefined)\n                that._min *= coef;\n        }, extendMax = function (coef) {\n            if (!that._maxDefined)\n                that._max *= coef;\n        };\n        if (this._equalSign) {\n            if (Math.abs(this._min) < Math.abs(this._max)) {\n                extendMin(0.95);\n                extendMax(1.05);\n            }\n            else {\n                extendMin(1.05);\n                extendMax(0.95);\n            }\n        }\n        else {\n            extendMin(1.05);\n            extendMax(1.05);\n        }\n        if (this._min === this._max) {\n            if (this._min !== 0)\n                this._max *= 1.4;\n            else\n                this._max = 1;\n        }\n    };\n    gaugeRangeCalculator.prototype._setRangeStart = function () {\n        if (this._equalSign) {\n            if (this._min === this._max) {\n                if (this._min > 0) {\n                    if (!this._minDefined)\n                        this._min = 0;\n                }\n                else {\n                    if (!this._maxDefined)\n                        this._max = 0;\n                }\n            }\n            if (Math.abs(this._min) <= Math.abs(this._max)) {\n                if (!this._minDefined)\n                    this._min = 0;\n            }\n            else {\n                if (!this._maxDefined)\n                    this._max = 0;\n            }\n        }\n    };\n    gaugeRangeCalculator.prototype._defineMinMax = function () {\n        if (this._minDefined)\n            this._min = this._customMin;\n        else\n            this._min = this._values.length > 0 ? Math.min.apply(Math, this._values) : 0;\n        if (this._maxDefined)\n            this._max = this._customMax;\n        else\n            this._max = this._values.length > 0 ? Math.max.apply(Math, this._values) : 1;\n        this._equalSign = this._signsEqual(this._min, this._max);\n    };\n    gaugeRangeCalculator.prototype._signsEqual = function (number1, number2) {\n        return (number1 >= 0 && number2 >= 0) || (number1 < 0 && number2 < 0);\n    };\n    gaugeRangeCalculator.prototype._defineMinMaxTicks = function () {\n        switch (this._gaugeViewType) {\n            case _utils_1.gaugeViewType.CircularFull:\n                this._minTickCount = 6;\n                this._maxTickCount = 9;\n                break;\n            case _utils_1.gaugeViewType.LinearHorizontal:\n                this._minTickCount = 3;\n                this._maxTickCount = 3;\n                break;\n            default:\n                this._minTickCount = 4;\n                this._maxTickCount = 6;\n                break;\n        }\n    };\n    gaugeRangeCalculator.prototype._chooseMultiplier = function (delta) {\n        var multipliers = [1, 2, 3, 5], result, exp, scale, normDelta, newResult, i;\n        if (delta > 1) {\n            for (var factor = 1;; factor *= 10) {\n                for (i = 0; i < multipliers.length; i++) {\n                    result = multipliers[i] * factor;\n                    if (delta <= result)\n                        return result;\n                }\n            }\n        }\n        else {\n            result = 10;\n            exp = Math.floor(Math.log(Math.abs(delta)) / Math.LN10);\n            scale = Math.pow(10, -exp);\n            normDelta = delta * scale;\n            for (i = multipliers.length - 1; i >= 0; i--) {\n                newResult = multipliers[i];\n                if (normDelta > newResult) {\n                    break;\n                }\n                result = newResult;\n            }\n            return result / scale;\n        }\n    };\n    return gaugeRangeCalculator;\n}());\nexports.gaugeRangeCalculator = gaugeRangeCalculator;\n"]},"metadata":{},"sourceType":"script"}